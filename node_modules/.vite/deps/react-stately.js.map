{
  "version": 3,
  "sources": ["../../@react-stately/calendar/dist/packages/@react-stately/calendar/src/index.ts", "../../@react-stately/calendar/dist/packages/@react-stately/calendar/src/useCalendarState.ts", "../../@react-stately/calendar/dist/packages/@react-stately/calendar/src/utils.ts", "../../@react-stately/calendar/dist/packages/@react-stately/calendar/src/useRangeCalendarState.ts", "../../@react-stately/checkbox/dist/packages/@react-stately/checkbox/src/index.ts", "../../@react-stately/checkbox/dist/packages/@react-stately/checkbox/src/useCheckboxGroupState.ts", "../../@react-stately/selection/dist/packages/@react-stately/selection/src/index.ts", "../../@react-stately/selection/dist/packages/@react-stately/selection/src/useMultipleSelectionState.ts", "../../@react-stately/selection/dist/packages/@react-stately/selection/src/Selection.ts", "../../@react-stately/selection/dist/packages/@react-stately/selection/src/SelectionManager.ts", "../../@react-stately/list/dist/packages/@react-stately/list/src/index.ts", "../../@react-stately/list/dist/packages/@react-stately/list/src/useListState.ts", "../../@react-stately/list/dist/packages/@react-stately/list/src/ListCollection.ts", "../../@react-stately/list/dist/packages/@react-stately/list/src/useSingleSelectListState.ts", "../../@react-stately/overlays/dist/packages/@react-stately/overlays/src/index.ts", "../../@react-stately/overlays/dist/packages/@react-stately/overlays/src/useOverlayTriggerState.ts", "../../@react-stately/menu/dist/packages/@react-stately/menu/src/index.ts", "../../@react-stately/menu/dist/packages/@react-stately/menu/src/useMenuTriggerState.ts", "../../@react-stately/combobox/dist/packages/@react-stately/combobox/src/index.ts", "../../@react-stately/combobox/dist/packages/@react-stately/combobox/src/useComboBoxState.ts", "../../@react-stately/datepicker/dist/packages/@react-stately/datepicker/src/index.ts", "../../@react-stately/datepicker/dist/packages/@react-stately/datepicker/src/useDatePickerState.ts", "../../@react-stately/datepicker/dist/packages/@react-stately/datepicker/src/utils.ts", "../../@react-stately/datepicker/dist/packages/@react-stately/datepicker/src/useDateFieldState.ts", "../../@react-stately/datepicker/dist/packages/@react-stately/datepicker/src/placeholders.ts", "../../@react-stately/datepicker/dist/packages/@react-stately/datepicker/src/useDateRangePickerState.ts", "../../@react-stately/datepicker/dist/packages/@react-stately/datepicker/src/useTimeFieldState.ts", "../../@react-stately/data/dist/packages/@react-stately/data/src/index.ts", "../../@react-stately/data/dist/packages/@react-stately/data/src/useAsyncList.ts", "../../@react-stately/data/dist/packages/@react-stately/data/src/useListData.ts", "../../@react-stately/data/dist/packages/@react-stately/data/src/useTreeData.ts", "../../@react-stately/numberfield/dist/packages/@react-stately/numberfield/src/index.ts", "../../@react-stately/numberfield/dist/packages/@react-stately/numberfield/src/useNumberFieldState.ts", "../../@react-stately/radio/dist/packages/@react-stately/radio/src/index.ts", "../../@react-stately/radio/dist/packages/@react-stately/radio/src/useRadioGroupState.ts", "../../@react-stately/searchfield/dist/packages/@react-stately/searchfield/src/index.ts", "../../@react-stately/searchfield/dist/packages/@react-stately/searchfield/src/useSearchFieldState.ts", "../../@react-stately/select/dist/packages/@react-stately/select/src/index.ts", "../../@react-stately/select/dist/packages/@react-stately/select/src/useSelectState.ts", "../../@react-stately/slider/dist/packages/@react-stately/slider/src/index.ts", "../../@react-stately/slider/dist/packages/@react-stately/slider/src/useSliderState.ts", "../../@react-stately/grid/dist/packages/@react-stately/grid/src/index.ts", "../../@react-stately/grid/dist/packages/@react-stately/grid/src/useGridState.ts", "../../@react-stately/grid/dist/packages/@react-stately/grid/src/GridCollection.ts", "../../@react-stately/table/dist/packages/@react-stately/table/src/index.ts", "../../@react-stately/table/dist/packages/@react-stately/table/src/useTableColumnResizeState.ts", "../../@react-stately/table/dist/packages/@react-stately/table/src/utils.ts", "../../@react-stately/table/dist/packages/@react-stately/table/src/useTableState.ts", "../../@react-stately/table/dist/packages/@react-stately/table/src/TableCollection.ts", "../../@react-stately/table/dist/packages/@react-stately/table/src/TableHeader.ts", "../../@react-stately/table/dist/packages/@react-stately/table/src/TableBody.ts", "../../@react-stately/table/dist/packages/@react-stately/table/src/Column.ts", "../../@react-stately/table/dist/packages/@react-stately/table/src/Row.ts", "../../@react-stately/table/dist/packages/@react-stately/table/src/Cell.ts", "../../@react-stately/tabs/dist/packages/@react-stately/tabs/src/index.ts", "../../@react-stately/tabs/dist/packages/@react-stately/tabs/src/useTabListState.ts", "../../@react-stately/tooltip/dist/packages/@react-stately/tooltip/src/index.ts", "../../@react-stately/tooltip/dist/packages/@react-stately/tooltip/src/useTooltipTriggerState.ts", "../../@react-stately/tree/dist/packages/@react-stately/tree/src/index.ts", "../../@react-stately/tree/dist/packages/@react-stately/tree/src/useTreeState.ts", "../../@react-stately/tree/dist/packages/@react-stately/tree/src/TreeCollection.ts"],
  "sourcesContent": ["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useCalendarState} from './useCalendarState';\nexport {useRangeCalendarState} from './useRangeCalendarState';\n\nexport type {CalendarStateOptions} from './useCalendarState';\nexport type {RangeCalendarStateOptions} from './useRangeCalendarState';\nexport type {CalendarState, RangeCalendarState} from './types';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {alignCenter, alignEnd, alignStart, constrainStart, constrainValue, isInvalid, previousAvailableDate} from './utils';\nimport {\n  Calendar,\n  CalendarDate,\n  DateDuration,\n  DateFormatter,\n  endOfMonth,\n  endOfWeek,\n  getDayOfWeek,\n  GregorianCalendar,\n  isSameDay,\n  startOfMonth,\n  startOfWeek,\n  toCalendar,\n  toCalendarDate,\n  today\n} from '@internationalized/date';\nimport {CalendarProps, DateValue} from '@react-types/calendar';\nimport {CalendarState} from './types';\nimport {useControlledState} from '@react-stately/utils';\nimport {useMemo, useRef, useState} from 'react';\n\nexport interface CalendarStateOptions extends CalendarProps<DateValue> {\n  /** The locale to display and edit the value according to. */\n  locale: string,\n  /**\n   * A function that creates a [Calendar](../internationalized/date/Calendar.html)\n   * object for a given calendar identifier. Such a function may be imported from the\n   * `@internationalized/date` package, or manually implemented to include support for\n   * only certain calendars.\n   */\n  createCalendar: (name: string) => Calendar,\n  /**\n   * The amount of days that will be displayed at once. This affects how pagination works.\n   * @default {months: 1}\n   */\n  visibleDuration?: DateDuration,\n  /** Determines how to align the initial selection relative to the visible date range. */\n  selectionAlignment?: 'start' | 'center' | 'end'\n}\n\n/**\n * Provides state management for a calendar component.\n * A calendar displays one or more date grids and allows users to select a single date.\n */\nexport function useCalendarState(props: CalendarStateOptions): CalendarState {\n  let defaultFormatter = useMemo(() => new DateFormatter(props.locale), [props.locale]);\n  let resolvedOptions = useMemo(() => defaultFormatter.resolvedOptions(), [defaultFormatter]);\n  let {\n    locale,\n    createCalendar,\n    visibleDuration = {months: 1},\n    minValue,\n    maxValue,\n    selectionAlignment,\n    isDateUnavailable\n  } = props;\n\n  let calendar = useMemo(() => createCalendar(resolvedOptions.calendar), [createCalendar, resolvedOptions.calendar]);\n\n  let [value, setControlledValue] = useControlledState<DateValue>(props.value, props.defaultValue, props.onChange);\n  let calendarDateValue = useMemo(() => value ? toCalendar(toCalendarDate(value), calendar) : null, [value, calendar]);\n  let timeZone = useMemo(() => value && 'timeZone' in value ? value.timeZone : resolvedOptions.timeZone, [value, resolvedOptions.timeZone]);\n  let focusedCalendarDate = useMemo(() => (\n    props.focusedValue\n      ? constrainValue(toCalendar(toCalendarDate(props.focusedValue), calendar), minValue, maxValue)\n      : undefined\n  ), [props.focusedValue, calendar, minValue, maxValue]);\n  let defaultFocusedCalendarDate = useMemo(() => (\n    constrainValue(\n      props.defaultFocusedValue\n        ? toCalendar(toCalendarDate(props.defaultFocusedValue), calendar)\n        : calendarDateValue || toCalendar(today(timeZone), calendar),\n      minValue,\n      maxValue\n    )\n  ), [props.defaultFocusedValue, calendarDateValue, timeZone, calendar, minValue, maxValue]);\n  let [focusedDate, setFocusedDate] = useControlledState(focusedCalendarDate, defaultFocusedCalendarDate, props.onFocusChange);\n  let [startDate, setStartDate] = useState(() => {\n    switch (selectionAlignment) {\n      case 'start':\n        return alignStart(focusedDate, visibleDuration, locale, minValue, maxValue);\n      case 'end':\n        return alignEnd(focusedDate, visibleDuration, locale, minValue, maxValue);\n      case 'center':\n      default:\n        return alignCenter(focusedDate, visibleDuration, locale, minValue, maxValue);\n    }\n  });\n  let [isFocused, setFocused] = useState(props.autoFocus || false);\n\n  let endDate = useMemo(() => {\n    let duration = {...visibleDuration};\n    if (duration.days) {\n      duration.days--;\n    } else {\n      duration.days = -1;\n    }\n    return startDate.add(duration);\n  }, [startDate, visibleDuration]);\n\n  // Reset focused date and visible range when calendar changes.\n  let lastCalendarIdentifier = useRef(calendar.identifier);\n  if (calendar.identifier !== lastCalendarIdentifier.current) {\n    let newFocusedDate = toCalendar(focusedDate, calendar);\n    setStartDate(alignCenter(newFocusedDate, visibleDuration, locale, minValue, maxValue));\n    setFocusedDate(newFocusedDate);\n    lastCalendarIdentifier.current = calendar.identifier;\n  }\n\n  if (isInvalid(focusedDate, minValue, maxValue)) {\n    // If the focused date was moved to an invalid value, it can't be focused, so constrain it.\n    setFocusedDate(constrainValue(focusedDate, minValue, maxValue));\n  } else if (focusedDate.compare(startDate) < 0) {\n    setStartDate(alignEnd(focusedDate, visibleDuration, locale, minValue, maxValue));\n  } else if (focusedDate.compare(endDate) > 0) {\n    setStartDate(alignStart(focusedDate, visibleDuration, locale, minValue, maxValue));\n  }\n\n  // Sets focus to a specific cell date\n  function focusCell(date: CalendarDate) {\n    date = constrainValue(date, minValue, maxValue);\n    setFocusedDate(date);\n  }\n\n  function setValue(newValue: CalendarDate) {\n    if (!props.isDisabled && !props.isReadOnly) {\n      newValue = constrainValue(newValue, minValue, maxValue);\n      newValue = previousAvailableDate(newValue, startDate, isDateUnavailable);\n      if (!newValue) {\n        return;\n      }\n\n      // The display calendar should not have any effect on the emitted value.\n      // Emit dates in the same calendar as the original value, if any, otherwise gregorian.\n      newValue = toCalendar(newValue, value?.calendar || new GregorianCalendar());\n\n      // Preserve time if the input value had one.\n      if (value && 'hour' in value) {\n        setControlledValue(value.set(newValue));\n      } else {\n        setControlledValue(newValue);\n      }\n    }\n  }\n\n  let isUnavailable = useMemo(() => {\n    if (!calendarDateValue) {\n      return false;\n    }\n\n    if (isDateUnavailable && isDateUnavailable(calendarDateValue)) {\n      return true;\n    }\n\n    return isInvalid(calendarDateValue, minValue, maxValue);\n  }, [calendarDateValue, isDateUnavailable, minValue, maxValue]);\n  let validationState = props.validationState || (isUnavailable ? 'invalid' : null);\n\n  return {\n    isDisabled: props.isDisabled,\n    isReadOnly: props.isReadOnly,\n    value: calendarDateValue,\n    setValue,\n    visibleRange: {\n      start: startDate,\n      end: endDate\n    },\n    minValue,\n    maxValue,\n    focusedDate,\n    timeZone,\n    validationState,\n    setFocusedDate(date) {\n      focusCell(date);\n      setFocused(true);\n    },\n    focusNextDay() {\n      focusCell(focusedDate.add({days: 1}));\n    },\n    focusPreviousDay() {\n      focusCell(focusedDate.subtract({days: 1}));\n    },\n    focusNextRow() {\n      if (visibleDuration.days) {\n        this.focusNextPage();\n      } else if (visibleDuration.weeks || visibleDuration.months || visibleDuration.years) {\n        focusCell(focusedDate.add({weeks: 1}));\n      }\n    },\n    focusPreviousRow() {\n      if (visibleDuration.days) {\n        this.focusPreviousPage();\n      } else if (visibleDuration.weeks || visibleDuration.months || visibleDuration.years) {\n        focusCell(focusedDate.subtract({weeks: 1}));\n      }\n    },\n    focusNextPage() {\n      let start = startDate.add(visibleDuration);\n      setFocusedDate(constrainValue(focusedDate.add(visibleDuration), minValue, maxValue));\n      setStartDate(\n        alignStart(\n          constrainStart(focusedDate, start, visibleDuration, locale, minValue, maxValue),\n          visibleDuration,\n          locale\n        )\n      );\n    },\n    focusPreviousPage() {\n      let start = startDate.subtract(visibleDuration);\n      setFocusedDate(constrainValue(focusedDate.subtract(visibleDuration), minValue, maxValue));\n      setStartDate(\n        alignStart(\n          constrainStart(focusedDate, start, visibleDuration, locale, minValue, maxValue),\n          visibleDuration,\n          locale\n        )\n      );\n    },\n    focusSectionStart() {\n      if (visibleDuration.days) {\n        focusCell(startDate);\n      } else if (visibleDuration.weeks) {\n        focusCell(startOfWeek(focusedDate, locale));\n      } else if (visibleDuration.months || visibleDuration.years) {\n        focusCell(startOfMonth(focusedDate));\n      }\n    },\n    focusSectionEnd() {\n      if (visibleDuration.days) {\n        focusCell(endDate);\n      } else if (visibleDuration.weeks) {\n        focusCell(endOfWeek(focusedDate, locale));\n      } else if (visibleDuration.months || visibleDuration.years) {\n        focusCell(endOfMonth(focusedDate));\n      }\n    },\n    focusNextSection(larger) {\n      if (!larger && !visibleDuration.days) {\n        focusCell(focusedDate.add(unitDuration(visibleDuration)));\n        return;\n      }\n\n      if (visibleDuration.days) {\n        this.focusNextPage();\n      } else if (visibleDuration.weeks) {\n        focusCell(focusedDate.add({months: 1}));\n      } else if (visibleDuration.months || visibleDuration.years) {\n        focusCell(focusedDate.add({years: 1}));\n      }\n    },\n    focusPreviousSection(larger) {\n      if (!larger && !visibleDuration.days) {\n        focusCell(focusedDate.subtract(unitDuration(visibleDuration)));\n        return;\n      }\n\n      if (visibleDuration.days) {\n        this.focusPreviousPage();\n      } else if (visibleDuration.weeks) {\n        focusCell(focusedDate.subtract({months: 1}));\n      } else if (visibleDuration.months || visibleDuration.years) {\n        focusCell(focusedDate.subtract({years: 1}));\n      }\n    },\n    selectFocusedDate() {\n      setValue(focusedDate);\n    },\n    selectDate(date) {\n      setValue(date);\n    },\n    isFocused,\n    setFocused,\n    isInvalid(date) {\n      return isInvalid(date, minValue, maxValue);\n    },\n    isSelected(date) {\n      return calendarDateValue != null && isSameDay(date, calendarDateValue) && !this.isCellDisabled(date) && !this.isCellUnavailable(date);\n    },\n    isCellFocused(date) {\n      return isFocused && focusedDate && isSameDay(date, focusedDate);\n    },\n    isCellDisabled(date) {\n      return props.isDisabled || date.compare(startDate) < 0 || date.compare(endDate) > 0 || this.isInvalid(date, minValue, maxValue);\n    },\n    isCellUnavailable(date) {\n      return props.isDateUnavailable && props.isDateUnavailable(date);\n    },\n    isPreviousVisibleRangeInvalid() {\n      let prev = startDate.subtract({days: 1});\n      return isSameDay(prev, startDate) || this.isInvalid(prev, minValue, maxValue);\n    },\n    isNextVisibleRangeInvalid() {\n      // Adding may return the same date if we reached the end of time\n      // according to the calendar system (e.g. 9999-12-31).\n      let next = endDate.add({days: 1});\n      return isSameDay(next, endDate) || this.isInvalid(next, minValue, maxValue);\n    },\n    getDatesInWeek(weekIndex, from = startDate) {\n      // let date = startOfWeek(from, locale);\n      let date = from.add({weeks: weekIndex});\n      let dates = [];\n\n      date = startOfWeek(date, locale);\n\n      // startOfWeek will clamp dates within the calendar system's valid range, which may\n      // start in the middle of a week. In this case, add null placeholders.\n      let dayOfWeek = getDayOfWeek(date, locale);\n      for (let i = 0; i < dayOfWeek; i++) {\n        dates.push(null);\n      }\n\n      while (dates.length < 7) {\n        dates.push(date);\n        let nextDate = date.add({days: 1});\n        if (isSameDay(date, nextDate)) {\n          // If the next day is the same, we have hit the end of the calendar system.\n          break;\n        }\n        date = nextDate;\n      }\n\n      // Add null placeholders if at the end of the calendar system.\n      while (dates.length < 7) {\n        dates.push(null);\n      }\n\n      return dates;\n    }\n  };\n}\n\nfunction unitDuration(duration: DateDuration) {\n  let unit = {...duration};\n  for (let key in duration) {\n    unit[key] = 1;\n  }\n  return unit;\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {\n  CalendarDate,\n  DateDuration,\n  maxDate,\n  minDate,\n  startOfMonth,\n  startOfWeek,\n  startOfYear,\n  toCalendarDate\n} from '@internationalized/date';\nimport {DateValue} from '@react-types/calendar';\n\nexport function isInvalid(date: DateValue, minValue: DateValue, maxValue: DateValue) {\n  return (minValue != null && date.compare(minValue) < 0) ||\n    (maxValue != null && date.compare(maxValue) > 0);\n}\n\nexport function alignCenter(date: CalendarDate, duration: DateDuration, locale: string, minValue?: DateValue, maxValue?: DateValue) {\n  let halfDuration: DateDuration = {};\n  for (let key in duration) {\n    halfDuration[key] = Math.floor(duration[key] / 2);\n    if (halfDuration[key] > 0 && duration[key] % 2 === 0) {\n      halfDuration[key]--;\n    }\n  }\n\n  let aligned = alignStart(date, duration, locale).subtract(halfDuration);\n  return constrainStart(date, aligned, duration, locale, minValue, maxValue);\n}\n\nexport function alignStart(date: CalendarDate, duration: DateDuration, locale: string, minValue?: DateValue, maxValue?: DateValue) {\n  // align to the start of the largest unit\n  let aligned = date;\n  if (duration.years) {\n    aligned = startOfYear(date);\n  } else if (duration.months) {\n    aligned = startOfMonth(date);\n  } else if (duration.weeks) {\n    aligned = startOfWeek(date, locale);\n  }\n\n  return constrainStart(date, aligned, duration, locale, minValue, maxValue);\n}\n\nexport function alignEnd(date: CalendarDate, duration: DateDuration, locale: string, minValue?: DateValue, maxValue?: DateValue) {\n  let d = {...duration};\n  // subtract 1 from the smallest unit\n  if (duration.days) {\n    d.days--;\n  } else if (duration.weeks) {\n    d.weeks--;\n  } else if (duration.months) {\n    d.months--;\n  } else if (duration.years) {\n    d.years--;\n  }\n\n  let aligned = alignStart(date, duration, locale).subtract(d);\n  return constrainStart(date, aligned, duration, locale, minValue, maxValue);\n}\n\nexport function constrainStart(\n  date: CalendarDate,\n  aligned: CalendarDate,\n  duration: DateDuration,\n  locale: string,\n  minValue: DateValue,\n  maxValue: DateValue) {\n  if (minValue && date.compare(minValue) >= 0) {\n    aligned = maxDate(\n      aligned,\n      alignStart(toCalendarDate(minValue), duration, locale)\n    );\n  }\n\n  if (maxValue && date.compare(maxValue) <= 0) {\n    aligned = minDate(\n      aligned,\n      alignEnd(toCalendarDate(maxValue), duration, locale)\n    );\n  }\n\n  return aligned;\n}\n\nexport function constrainValue(date: CalendarDate, minValue: DateValue, maxValue: DateValue) {\n  if (minValue) {\n    date = maxDate(date, toCalendarDate(minValue));\n  }\n\n  if (maxValue) {\n    date = minDate(date, toCalendarDate(maxValue));\n  }\n\n  return date;\n}\n\nexport function previousAvailableDate(date: CalendarDate, minValue: DateValue, isDateUnavailable: (date: CalendarDate) => boolean) {\n  if (!isDateUnavailable) {\n    return date;\n  }\n\n  while (date.compare(minValue) >= 0 && isDateUnavailable(date)) {\n    date = date.subtract({days: 1});\n  }\n\n  if (date.compare(minValue) >= 0) {\n    return date;\n  }\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {alignCenter, constrainValue, isInvalid, previousAvailableDate} from './utils';\nimport {Calendar, CalendarDate, DateDuration, GregorianCalendar, isEqualDay, maxDate, minDate, toCalendar, toCalendarDate} from '@internationalized/date';\nimport {CalendarState, RangeCalendarState} from './types';\nimport {DateRange, DateValue} from '@react-types/calendar';\nimport {RangeCalendarProps} from '@react-types/calendar';\nimport {RangeValue} from '@react-types/shared';\nimport {useCalendarState} from './useCalendarState';\nimport {useControlledState} from '@react-stately/utils';\nimport {useMemo, useRef, useState} from 'react';\n\nexport interface RangeCalendarStateOptions extends RangeCalendarProps<DateValue> {\n  /** The locale to display and edit the value according to. */\n  locale: string,\n  /**\n   * A function that creates a [Calendar](../internationalized/date/Calendar.html)\n   * object for a given calendar identifier. Such a function may be imported from the\n   * `@internationalized/date` package, or manually implemented to include support for\n   * only certain calendars.\n   */\n  createCalendar: (name: string) => Calendar,\n  /**\n   * The amount of days that will be displayed at once. This affects how pagination works.\n   * @default {months: 1}\n   */\n  visibleDuration?: DateDuration\n}\n\n/**\n * Provides state management for a range calendar component.\n * A range calendar displays one or more date grids and allows users to select a contiguous range of dates.\n */\nexport function useRangeCalendarState(props: RangeCalendarStateOptions): RangeCalendarState {\n  let {value: valueProp, defaultValue, onChange, createCalendar, locale, visibleDuration = {months: 1}, minValue, maxValue, ...calendarProps} = props;\n  let [value, setValue] = useControlledState<DateRange>(\n    valueProp,\n    defaultValue || null,\n    onChange\n  );\n\n  let [anchorDate, setAnchorDateState] = useState(null);\n  let alignment: 'center' | 'start' = 'center';\n  if (value && value.start && value.end) {\n    let start = alignCenter(toCalendarDate(value.start), visibleDuration, locale, minValue, maxValue);\n    let end = start.add(visibleDuration).subtract({days: 1});\n\n    if (value.end.compare(end) > 0) {\n      alignment = 'start';\n    }\n  }\n\n  // Available range must be stored in a ref so we have access to the updated version immediately in `isInvalid`.\n  let availableRangeRef = useRef<RangeValue<DateValue>>(null);\n  let [availableRange, setAvailableRange] = useState<RangeValue<DateValue>>(null);\n  let min = useMemo(() => maxDate(minValue, availableRange?.start), [minValue, availableRange]);\n  let max = useMemo(() => minDate(maxValue, availableRange?.end), [maxValue, availableRange]);\n\n  let calendar = useCalendarState({\n    ...calendarProps,\n    value: value && value.start,\n    createCalendar,\n    locale,\n    visibleDuration,\n    minValue: min,\n    maxValue: max,\n    selectionAlignment: alignment\n  });\n\n  let updateAvailableRange = (date) => {\n    if (date && props.isDateUnavailable && !props.allowsNonContiguousRanges) {\n      availableRangeRef.current = {\n        start: nextUnavailableDate(date, calendar, -1),\n        end: nextUnavailableDate(date, calendar, 1)\n      };\n      setAvailableRange(availableRangeRef.current);\n    } else {\n      availableRangeRef.current = null;\n      setAvailableRange(null);\n    }\n  };\n\n  // If the visible range changes, we need to update the available range.\n  let lastVisibleRange = useRef(calendar.visibleRange);\n  if (!isEqualDay(calendar.visibleRange.start, lastVisibleRange.current.start) || !isEqualDay(calendar.visibleRange.end, lastVisibleRange.current.end)) {\n    updateAvailableRange(anchorDate);\n    lastVisibleRange.current = calendar.visibleRange;\n  }\n\n  let setAnchorDate = (date: CalendarDate) => {\n    if (date) {\n      setAnchorDateState(date);\n      updateAvailableRange(date);\n    } else {\n      setAnchorDateState(null);\n      updateAvailableRange(null);\n    }\n  };\n\n  let highlightedRange = anchorDate ? makeRange(anchorDate, calendar.focusedDate) : value && makeRange(value.start, value.end);\n  let selectDate = (date: CalendarDate) => {\n    if (props.isReadOnly) {\n      return;\n    }\n\n    date = constrainValue(date, min, max);\n    date = previousAvailableDate(date, calendar.visibleRange.start, props.isDateUnavailable);\n    if (!date) {\n      return;\n    }\n\n    if (!anchorDate) {\n      setAnchorDate(date);\n    } else {\n      let range = makeRange(anchorDate, date);\n      setValue({\n        start: convertValue(range.start, value?.start),\n        end: convertValue(range.end, value?.end)\n      });\n      setAnchorDate(null);\n    }\n  };\n\n  let [isDragging, setDragging] = useState(false);\n\n  let {isDateUnavailable} = props;\n  let isInvalidSelection = useMemo(() => {\n    if (!value || anchorDate) {\n      return false;\n    }\n\n    if (isDateUnavailable && (isDateUnavailable(value.start) || isDateUnavailable(value.end))) {\n      return true;\n    }\n\n    return isInvalid(value.start, minValue, maxValue) || isInvalid(value.end, minValue, maxValue);\n  }, [isDateUnavailable, value, anchorDate, minValue, maxValue]);\n\n  let validationState = props.validationState || (isInvalidSelection ? 'invalid' : null);\n\n  return {\n    ...calendar,\n    value,\n    setValue,\n    anchorDate,\n    setAnchorDate,\n    highlightedRange,\n    validationState,\n    selectFocusedDate() {\n      selectDate(calendar.focusedDate);\n    },\n    selectDate,\n    highlightDate(date) {\n      if (anchorDate) {\n        calendar.setFocusedDate(date);\n      }\n    },\n    isSelected(date) {\n      return highlightedRange && date.compare(highlightedRange.start) >= 0 && date.compare(highlightedRange.end) <= 0 && !calendar.isCellDisabled(date) && !calendar.isCellUnavailable(date);\n    },\n    isInvalid(date) {\n      return calendar.isInvalid(date) || isInvalid(date, availableRangeRef.current?.start, availableRangeRef.current?.end);\n    },\n    isDragging,\n    setDragging\n  };\n}\n\nfunction makeRange(start: DateValue, end: DateValue): RangeValue<CalendarDate> {\n  if (!start || !end) {\n    return null;\n  }\n\n  if (end.compare(start) < 0) {\n    [start, end] = [end, start];\n  }\n\n  return {start: toCalendarDate(start), end: toCalendarDate(end)};\n}\n\nfunction convertValue(newValue: CalendarDate, oldValue: DateValue) {\n  // The display calendar should not have any effect on the emitted value.\n  // Emit dates in the same calendar as the original value, if any, otherwise gregorian.\n  newValue = toCalendar(newValue, oldValue?.calendar || new GregorianCalendar());\n\n  // Preserve time if the input value had one.\n  if (oldValue && 'hour' in oldValue) {\n    return oldValue.set(newValue);\n  }\n\n  return newValue;\n}\n\nfunction nextUnavailableDate(anchorDate: CalendarDate, state: CalendarState, dir: number) {\n  let nextDate = anchorDate.add({days: dir});\n  while (\n    (dir < 0 ? nextDate.compare(state.visibleRange.start) >= 0 : nextDate.compare(state.visibleRange.end) <= 0) &&\n    !state.isCellUnavailable(nextDate)\n  ) {\n    nextDate = nextDate.add({days: dir});\n  }\n\n  if (state.isCellUnavailable(nextDate)) {\n    return nextDate.add({days: -dir});\n  }\n\n  return null;\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useCheckboxGroupState} from './useCheckboxGroupState';\n\nexport type {CheckboxGroupProps} from '@react-types/checkbox';\nexport type {CheckboxGroupState} from './useCheckboxGroupState';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CheckboxGroupProps} from '@react-types/checkbox';\nimport {useControlledState} from '@react-stately/utils';\nimport {ValidationState} from '@react-types/shared';\n\nexport interface CheckboxGroupState {\n  /** Current selected values. */\n  readonly value: readonly string[],\n\n  /** Whether the checkbox group is disabled. */\n  readonly isDisabled: boolean,\n\n  /** Whether the checkbox group is read only. */\n  readonly isReadOnly: boolean,\n\n  /** Returns whether the given value is selected. */\n  isSelected(value: string): boolean,\n\n  /** Sets the selected values. */\n  setValue(value: string[]): void,\n\n  /** Adds a value to the set of selected values. */\n  addValue(value: string): void,\n\n  /** Removes a value from the set of selected values. */\n  removeValue(value: string): void,\n\n  /** Toggles a value in the set of selected values. */\n  toggleValue(value: string): void,\n\n  /** The current validation state of the checkbox group. */\n  validationState: ValidationState\n}\n\n/**\n * Provides state management for a checkbox group component. Provides a name for the group,\n * and manages selection and focus state.\n */\nexport function useCheckboxGroupState(props: CheckboxGroupProps = {}): CheckboxGroupState {\n  let [selectedValues, setValue] = useControlledState(props.value, props.defaultValue || [], props.onChange);\n\n  const state: CheckboxGroupState = {\n    value: selectedValues,\n    setValue(value) {\n      if (props.isReadOnly || props.isDisabled) {\n        return;\n      }\n\n      setValue(value);\n    },\n    isDisabled: props.isDisabled || false,\n    isReadOnly: props.isReadOnly || false,\n    isSelected(value) {\n      return selectedValues.includes(value);\n    },\n    addValue(value) {\n      if (props.isReadOnly || props.isDisabled) {\n        return;\n      }\n      if (!selectedValues.includes(value)) {\n        setValue(selectedValues.concat(value));\n      }\n    },\n    removeValue(value) {\n      if (props.isReadOnly || props.isDisabled) {\n        return;\n      }\n      if (selectedValues.includes(value)) {\n        setValue(selectedValues.filter(existingValue => existingValue !== value));\n      }\n    },\n    toggleValue(value) {\n      if (props.isReadOnly || props.isDisabled) {\n        return;\n      }\n      if (selectedValues.includes(value)) {\n        setValue(selectedValues.filter(existingValue => existingValue !== value));\n      } else {\n        setValue(selectedValues.concat(value));\n      }\n    },\n    validationState: props.validationState\n  };\n\n  return state;\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport type {MultipleSelectionStateProps} from './useMultipleSelectionState';\nexport type {FocusState, SingleSelectionState, MultipleSelectionState, MultipleSelectionManager} from './types';\nexport {useMultipleSelectionState} from './useMultipleSelectionState';\nexport {SelectionManager} from './SelectionManager';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DisabledBehavior, MultipleSelection, SelectionBehavior, SelectionMode} from '@react-types/shared';\nimport {Key, useEffect, useMemo, useRef, useState} from 'react';\nimport {MultipleSelectionState} from './types';\nimport {Selection} from './Selection';\nimport {useControlledState} from '@react-stately/utils';\n\nfunction equalSets(setA, setB) {\n  if (setA.size !== setB.size) {\n    return false;\n  }\n\n  for (let item of setA) {\n    if (!setB.has(item)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport interface MultipleSelectionStateProps extends MultipleSelection {\n  /** How multiple selection should behave in the collection. */\n  selectionBehavior?: SelectionBehavior,\n  /** Whether onSelectionChange should fire even if the new set of keys is the same as the last. */\n  allowDuplicateSelectionEvents?: boolean,\n  /** Whether `disabledKeys` applies to all interactions, or only selection. */\n  disabledBehavior?: DisabledBehavior\n}\n\n/**\n * Manages state for multiple selection and focus in a collection.\n */\nexport function useMultipleSelectionState(props: MultipleSelectionStateProps): MultipleSelectionState {\n  let {\n    selectionMode = 'none' as SelectionMode,\n    disallowEmptySelection,\n    allowDuplicateSelectionEvents,\n    selectionBehavior: selectionBehaviorProp = 'toggle',\n    disabledBehavior = 'all'\n  } = props;\n\n  // We want synchronous updates to `isFocused` and `focusedKey` after their setters are called.\n  // But we also need to trigger a react re-render. So, we have both a ref (sync) and state (async).\n  let isFocusedRef = useRef(false);\n  let [, setFocused] = useState(false);\n  let focusedKeyRef = useRef(null);\n  let childFocusStrategyRef = useRef(null);\n  let [, setFocusedKey] = useState(null);\n  let selectedKeysProp = useMemo(() => convertSelection(props.selectedKeys), [props.selectedKeys]);\n  let defaultSelectedKeys = useMemo(() => convertSelection(props.defaultSelectedKeys, new Selection()), [props.defaultSelectedKeys]);\n  let [selectedKeys, setSelectedKeys] = useControlledState(\n    selectedKeysProp,\n    defaultSelectedKeys,\n    props.onSelectionChange\n  );\n  let disabledKeysProp = useMemo(() =>\n    props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()\n  , [props.disabledKeys]);\n  let [selectionBehavior, setSelectionBehavior] = useState(selectionBehaviorProp);\n\n  // If the selectionBehavior prop is set to replace, but the current state is toggle (e.g. due to long press\n  // to enter selection mode on touch), and the selection becomes empty, reset the selection behavior.\n  if (selectionBehaviorProp === 'replace' && selectionBehavior === 'toggle' && typeof selectedKeys === 'object' && selectedKeys.size === 0) {\n    setSelectionBehavior('replace');\n  }\n\n  // If the selectionBehavior prop changes, update the state as well.\n  let lastSelectionBehavior = useRef(selectionBehaviorProp);\n  useEffect(() => {\n    if (selectionBehaviorProp !== lastSelectionBehavior.current) {\n      setSelectionBehavior(selectionBehaviorProp);\n      lastSelectionBehavior.current = selectionBehaviorProp;\n    }\n  }, [selectionBehaviorProp]);\n\n  return {\n    selectionMode,\n    disallowEmptySelection,\n    selectionBehavior,\n    setSelectionBehavior,\n    get isFocused() {\n      return isFocusedRef.current;\n    },\n    setFocused(f) {\n      isFocusedRef.current = f;\n      setFocused(f);\n    },\n    get focusedKey() {\n      return focusedKeyRef.current;\n    },\n    get childFocusStrategy() {\n      return childFocusStrategyRef.current;\n    },\n    setFocusedKey(k, childFocusStrategy = 'first') {\n      focusedKeyRef.current = k;\n      childFocusStrategyRef.current = childFocusStrategy;\n      setFocusedKey(k);\n    },\n    selectedKeys,\n    setSelectedKeys(keys) {\n      if (allowDuplicateSelectionEvents || !equalSets(keys, selectedKeys)) {\n        setSelectedKeys(keys);\n      }\n    },\n    disabledKeys: disabledKeysProp,\n    disabledBehavior\n  };\n}\n\nfunction convertSelection(selection: 'all' | Iterable<Key>, defaultValue?: Selection): 'all' | Selection {\n  if (!selection) {\n    return defaultValue;\n  }\n\n  return selection === 'all'\n    ? 'all'\n    : new Selection(selection);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from 'react';\n\n/**\n * A Selection is a special Set containing Keys, which also has an anchor\n * and current selected key for use when range selecting.\n */\nexport class Selection extends Set<Key> {\n  anchorKey: Key;\n  currentKey: Key;\n\n  constructor(keys?: Iterable<Key> | Selection, anchorKey?: Key, currentKey?: Key) {\n    super(keys);\n    if (keys instanceof Selection) {\n      this.anchorKey = anchorKey || keys.anchorKey;\n      this.currentKey = currentKey || keys.currentKey;\n    } else {\n      this.anchorKey = anchorKey;\n      this.currentKey = currentKey;\n    }\n  }\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n  Collection,\n  DisabledBehavior,\n  FocusStrategy,\n  Selection as ISelection,\n  LongPressEvent,\n  Node,\n  PressEvent,\n  SelectionBehavior,\n  SelectionMode\n} from '@react-types/shared';\nimport {Key} from 'react';\nimport {MultipleSelectionManager, MultipleSelectionState} from './types';\nimport {Selection} from './Selection';\n\ninterface SelectionManagerOptions {\n  allowsCellSelection?: boolean\n}\n\n/**\n * An interface for reading and updating multiple selection state.\n */\nexport class SelectionManager implements MultipleSelectionManager {\n  private collection: Collection<Node<unknown>>;\n  private state: MultipleSelectionState;\n  private allowsCellSelection: boolean;\n  private _isSelectAll: boolean;\n\n  constructor(collection: Collection<Node<unknown>>, state: MultipleSelectionState, options?: SelectionManagerOptions) {\n    this.collection = collection;\n    this.state = state;\n    this.allowsCellSelection = options?.allowsCellSelection ?? false;\n    this._isSelectAll = null;\n  }\n\n  /**\n   * The type of selection that is allowed in the collection.\n   */\n  get selectionMode(): SelectionMode {\n    return this.state.selectionMode;\n  }\n\n  /**\n   * Whether the collection allows empty selection.\n   */\n  get disallowEmptySelection(): boolean {\n    return this.state.disallowEmptySelection;\n  }\n\n  /**\n   * The selection behavior for the collection.\n   */\n  get selectionBehavior(): SelectionBehavior {\n    return this.state.selectionBehavior;\n  }\n\n  /**\n   * Sets the selection behavior for the collection.\n   */\n  setSelectionBehavior(selectionBehavior: SelectionBehavior) {\n    this.state.setSelectionBehavior(selectionBehavior);\n  }\n\n  /**\n   * Whether the collection is currently focused.\n   */\n  get isFocused(): boolean {\n    return this.state.isFocused;\n  }\n\n  /**\n   * Sets whether the collection is focused.\n   */\n  setFocused(isFocused: boolean) {\n    this.state.setFocused(isFocused);\n  }\n\n  /**\n   * The current focused key in the collection.\n   */\n  get focusedKey(): Key {\n    return this.state.focusedKey;\n  }\n\n  /** Whether the first or last child of the focused key should receive focus. */\n  get childFocusStrategy(): FocusStrategy {\n    return this.state.childFocusStrategy;\n  }\n\n  /**\n   * Sets the focused key.\n   */\n  setFocusedKey(key: Key, childFocusStrategy?: FocusStrategy) {\n    if (key == null || this.collection.getItem(key)) {\n      this.state.setFocusedKey(key, childFocusStrategy);\n    }\n  }\n\n  /**\n   * The currently selected keys in the collection.\n   */\n  get selectedKeys(): Set<Key> {\n    return this.state.selectedKeys === 'all'\n      ? new Set(this.getSelectAllKeys())\n      : this.state.selectedKeys;\n  }\n\n  /**\n   * The raw selection value for the collection.\n   * Either 'all' for select all, or a set of keys.\n   */\n  get rawSelection(): ISelection {\n    return this.state.selectedKeys;\n  }\n\n  /**\n   * Returns whether a key is selected.\n   */\n  isSelected(key: Key) {\n    if (this.state.selectionMode === 'none') {\n      return false;\n    }\n\n    key = this.getKey(key);\n    return this.state.selectedKeys === 'all'\n      ? this.canSelectItem(key)\n      : this.state.selectedKeys.has(key);\n  }\n\n  /**\n   * Whether the selection is empty.\n   */\n  get isEmpty(): boolean {\n    return this.state.selectedKeys !== 'all' && this.state.selectedKeys.size === 0;\n  }\n\n  /**\n   * Whether all items in the collection are selected.\n   */\n  get isSelectAll(): boolean {\n    if (this.isEmpty) {\n      return false;\n    }\n\n    if (this.state.selectedKeys === 'all') {\n      return true;\n    }\n\n    if (this._isSelectAll != null) {\n      return this._isSelectAll;\n    }\n\n    let allKeys = this.getSelectAllKeys();\n    let selectedKeys = this.state.selectedKeys;\n    this._isSelectAll = allKeys.every(k => selectedKeys.has(k));\n    return this._isSelectAll;\n  }\n\n  get firstSelectedKey(): Key | null {\n    let first: Node<unknown> | null = null;\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!first || item?.index < first.index) {\n        first = item;\n      }\n    }\n\n    return first?.key;\n  }\n\n  get lastSelectedKey(): Key | null {\n    let last: Node<unknown> | null = null;\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!last || item?.index > last.index) {\n        last = item;\n      }\n    }\n\n    return last?.key;\n  }\n\n  get disabledKeys(): Set<Key> {\n    return this.state.disabledKeys;\n  }\n\n  get disabledBehavior(): DisabledBehavior {\n    return this.state.disabledBehavior;\n  }\n\n  /**\n   * Extends the selection to the given key.\n   */\n  extendSelection(toKey: Key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single') {\n      this.replaceSelection(toKey);\n      return;\n    }\n\n    toKey = this.getKey(toKey);\n\n    let selection: Selection;\n\n    // Only select the one key if coming from a select all.\n    if (this.state.selectedKeys === 'all') {\n      selection = new Selection([toKey], toKey, toKey);\n    } else {\n      let selectedKeys = this.state.selectedKeys as Selection;\n      let anchorKey = selectedKeys.anchorKey || toKey;\n      selection = new Selection(selectedKeys, anchorKey, toKey);\n      for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey)) {\n        selection.delete(key);\n      }\n\n      for (let key of this.getKeyRange(toKey, anchorKey)) {\n        if (this.canSelectItem(key)) {\n          selection.add(key);\n        }\n      }\n    }\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  private getKeyRange(from: Key, to: Key) {\n    let fromItem = this.collection.getItem(from);\n    let toItem = this.collection.getItem(to);\n    if (fromItem && toItem) {\n      if (fromItem.index <= toItem.index) {\n        return this.getKeyRangeInternal(from, to);\n      }\n\n      return this.getKeyRangeInternal(to, from);\n    }\n\n    return [];\n  }\n\n  private getKeyRangeInternal(from: Key, to: Key) {\n    let keys: Key[] = [];\n    let key = from;\n    while (key) {\n      let item = this.collection.getItem(key);\n      if (item && item.type === 'item' || (item.type === 'cell' && this.allowsCellSelection)) {\n        keys.push(key);\n      }\n\n      if (key === to) {\n        return keys;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n\n    return [];\n  }\n\n  private getKey(key: Key) {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      // \u00AF\\_(\u30C4)_/\u00AF\n      return key;\n    }\n\n    // If cell selection is allowed, just return the key.\n    if (item.type === 'cell' && this.allowsCellSelection) {\n      return key;\n    }\n\n    // Find a parent item to select\n    while (item.type !== 'item' && item.parentKey != null) {\n      item = this.collection.getItem(item.parentKey);\n    }\n\n    if (!item || item.type !== 'item') {\n      return null;\n    }\n\n    return item.key;\n  }\n\n  /**\n   * Toggles whether the given key is selected.\n   */\n  toggleSelection(key: Key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single' && !this.isSelected(key)) {\n      this.replaceSelection(key);\n      return;\n    }\n\n    key = this.getKey(key);\n    if (key == null) {\n      return;\n    }\n\n    let keys = new Selection(this.state.selectedKeys === 'all' ? this.getSelectAllKeys() : this.state.selectedKeys);\n    if (keys.has(key)) {\n      keys.delete(key);\n      // TODO: move anchor to last selected key...\n      // Does `current` need to move here too?\n    } else if (this.canSelectItem(key)) {\n      keys.add(key);\n      keys.anchorKey = key;\n      keys.currentKey = key;\n    }\n\n    if (this.disallowEmptySelection && keys.size === 0) {\n      return;\n    }\n\n    this.state.setSelectedKeys(keys);\n  }\n\n  /**\n   * Replaces the selection with only the given key.\n   */\n  replaceSelection(key: Key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    key = this.getKey(key);\n    if (key == null) {\n      return;\n    }\n\n    let selection = this.canSelectItem(key)\n      ? new Selection([key], key, key)\n      : new Selection();\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  /**\n   * Replaces the selection with the given keys.\n   */\n  setSelectedKeys(keys: Iterable<Key>) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    let selection = new Selection();\n    for (let key of keys) {\n      key = this.getKey(key);\n      if (key != null) {\n        selection.add(key);\n        if (this.selectionMode === 'single') {\n          break;\n        }\n      }\n    }\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  private getSelectAllKeys() {\n    let keys: Key[] = [];\n    let addKeys = (key: Key) => {\n      while (key) {\n        if (this.canSelectItem(key)) {\n          let item = this.collection.getItem(key);\n          if (item.type === 'item') {\n            keys.push(key);\n          }\n\n          // Add child keys. If cell selection is allowed, then include item children too.\n          if (item.hasChildNodes && (this.allowsCellSelection || item.type !== 'item')) {\n            addKeys([...item.childNodes][0].key);\n          }\n        }\n\n        key = this.collection.getKeyAfter(key);\n      }\n    };\n\n    addKeys(this.collection.getFirstKey());\n    return keys;\n  }\n\n  /**\n   * Selects all items in the collection.\n   */\n  selectAll() {\n    if (this.selectionMode === 'multiple') {\n      this.state.setSelectedKeys('all');\n    }\n  }\n\n  /**\n   * Removes all keys from the selection.\n   */\n  clearSelection() {\n    if (!this.disallowEmptySelection && (this.state.selectedKeys === 'all' || this.state.selectedKeys.size > 0)) {\n      this.state.setSelectedKeys(new Selection());\n    }\n  }\n\n  /**\n   * Toggles between select all and an empty selection.\n   */\n  toggleSelectAll() {\n    if (this.isSelectAll) {\n      this.clearSelection();\n    } else {\n      this.selectAll();\n    }\n  }\n\n  select(key: Key, e?: PressEvent | LongPressEvent | PointerEvent) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single') {\n      if (this.isSelected(key) && !this.disallowEmptySelection) {\n        this.toggleSelection(key);\n      } else {\n        this.replaceSelection(key);\n      }\n    } else if (this.selectionBehavior === 'toggle' || (e && (e.pointerType === 'touch' || e.pointerType === 'virtual'))) {\n      // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n      this.toggleSelection(key);\n    } else {\n      this.replaceSelection(key);\n    }\n  }\n\n  /**\n   * Returns whether the current selection is equal to the given selection.\n   */\n  isSelectionEqual(selection: Set<Key>) {\n    if (selection === this.state.selectedKeys) {\n      return true;\n    }\n\n    // Check if the set of keys match.\n    let selectedKeys = this.selectedKeys;\n    if (selection.size !== selectedKeys.size) {\n      return false;\n    }\n\n    for (let key of selection) {\n      if (!selectedKeys.has(key)) {\n        return false;\n      }\n    }\n\n    for (let key of selectedKeys) {\n      if (!selection.has(key)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  canSelectItem(key: Key) {\n    if (this.state.selectionMode === 'none' || this.state.disabledKeys.has(key)) {\n      return false;\n    }\n\n    let item = this.collection.getItem(key);\n    if (!item || (item.type === 'cell' && !this.allowsCellSelection)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  isDisabled(key: Key) {\n    return this.state.disabledKeys.has(key) && this.state.disabledBehavior === 'all';\n  }\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport type {ListProps, ListState} from './useListState';\nexport type {SingleSelectListProps, SingleSelectListState} from './useSingleSelectListState';\nexport {useListState} from './useListState';\nexport {useSingleSelectListState} from './useSingleSelectListState';\nexport {ListCollection} from './ListCollection';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, CollectionBase, Node} from '@react-types/shared';\nimport {Key, useEffect, useMemo} from 'react';\nimport {ListCollection} from './ListCollection';\nimport {MultipleSelectionStateProps, SelectionManager, useMultipleSelectionState} from '@react-stately/selection';\nimport {useCollection} from '@react-stately/collections';\n\nexport interface ListProps<T> extends CollectionBase<T>, MultipleSelectionStateProps {\n  /** Filter function to generate a filtered list of nodes. */\n  filter?: (nodes: Iterable<Node<T>>) => Iterable<Node<T>>,\n  /** @private */\n  suppressTextValueWarning?: boolean\n}\n\nexport interface ListState<T> {\n  /** A collection of items in the list. */\n  collection: Collection<Node<T>>,\n\n  /** A set of items that are disabled. */\n  disabledKeys: Set<Key>,\n\n  /** A selection manager to read and update multiple selection state. */\n  selectionManager: SelectionManager\n}\n\n/**\n * Provides state management for list-like components. Handles building a collection\n * of items from props, and manages multiple selection state.\n */\nexport function useListState<T extends object>(props: ListProps<T>): ListState<T>  {\n  let {filter} = props;\n\n  let selectionState = useMultipleSelectionState(props);\n  let disabledKeys = useMemo(() =>\n    props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()\n  , [props.disabledKeys]);\n\n  let factory = nodes => filter ? new ListCollection(filter(nodes)) : new ListCollection(nodes as Iterable<Node<T>>);\n  let context = useMemo(() => ({suppressTextValueWarning: props.suppressTextValueWarning}), [props.suppressTextValueWarning]);\n\n  let collection = useCollection(props, factory, context, [filter]);\n\n  // Reset focused key if that item is deleted from the collection.\n  useEffect(() => {\n    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n      selectionState.setFocusedKey(null);\n    }\n  }, [collection, selectionState.focusedKey]);\n\n  return {\n    collection,\n    disabledKeys,\n    selectionManager: new SelectionManager(collection, selectionState)\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, Node} from '@react-types/shared';\nimport {Key} from 'react';\n\nexport class ListCollection<T> implements Collection<Node<T>> {\n  private keyMap: Map<Key, Node<T>> = new Map();\n  private iterable: Iterable<Node<T>>;\n  private firstKey: Key;\n  private lastKey: Key;\n\n  constructor(nodes: Iterable<Node<T>>) {\n    this.iterable = nodes;\n\n    let visit = (node: Node<T>) => {\n      this.keyMap.set(node.key, node);\n\n      if (node.childNodes && node.type === 'section') {\n        for (let child of node.childNodes) {\n          visit(child);\n        }\n      }\n    };\n\n    for (let node of nodes) {\n      visit(node);\n    }\n\n    let last: Node<T>;\n    let index = 0;\n    for (let [key, node] of this.keyMap) {\n      if (last) {\n        last.nextKey = key;\n        node.prevKey = last.key;\n      } else {\n        this.firstKey = key;\n        node.prevKey = undefined;\n      }\n\n      if (node.type === 'item') {\n        node.index = index++;\n      }\n\n      last = node;\n\n      // Set nextKey as undefined since this might be the last node\n      // If it isn't the last node, last.nextKey will properly set at start of new loop\n      last.nextKey = undefined;\n    }\n\n    this.lastKey = last?.key;\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.iterable;\n  }\n\n  get size() {\n    return this.keyMap.size;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    return this.firstKey;\n  }\n\n  getLastKey() {\n    return this.lastKey;\n  }\n\n  getItem(key: Key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx: number) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CollectionBase, SingleSelection} from '@react-types/shared';\nimport {Key, useMemo} from 'react';\nimport {ListState, useListState} from './useListState';\nimport {Node} from '@react-types/shared';\nimport {useControlledState} from '@react-stately/utils';\n\nexport interface SingleSelectListProps<T> extends CollectionBase<T>, Omit<SingleSelection, 'disallowEmptySelection'> {\n  /** Filter function to generate a filtered list of nodes. */\n  filter?: (nodes: Iterable<Node<T>>) => Iterable<Node<T>>,\n  /** @private */\n  suppressTextValueWarning?: boolean\n}\n\nexport interface SingleSelectListState<T> extends ListState<T> {\n  /** The key for the currently selected item. */\n  readonly selectedKey: Key,\n\n  /** Sets the selected key. */\n  setSelectedKey(key: Key): void,\n\n  /** The value of the currently selected item. */\n  readonly selectedItem: Node<T>\n}\n\n/**\n * Provides state management for list-like components with single selection.\n * Handles building a collection of items from props, and manages selection state.\n */\nexport function useSingleSelectListState<T extends object>(props: SingleSelectListProps<T>): SingleSelectListState<T>  {\n  let [selectedKey, setSelectedKey] = useControlledState(props.selectedKey, props.defaultSelectedKey ?? null, props.onSelectionChange);\n  let selectedKeys = useMemo(() => selectedKey != null ? [selectedKey] : [], [selectedKey]);\n  let {collection, disabledKeys, selectionManager} = useListState({\n    ...props,\n    selectionMode: 'single',\n    disallowEmptySelection: true,\n    allowDuplicateSelectionEvents: true,\n    selectedKeys,\n    onSelectionChange: (keys: Set<Key>) => {\n      let key = keys.values().next().value;\n\n      // Always fire onSelectionChange, even if the key is the same\n      // as the current key (useControlledState does not).\n      if (key === selectedKey && props.onSelectionChange) {\n        props.onSelectionChange(key);\n      }\n\n      setSelectedKey(key);\n    }\n  });\n\n  let selectedItem = selectedKey != null\n    ? collection.getItem(selectedKey)\n    : null;\n\n  return {\n    collection,\n    disabledKeys,\n    selectionManager,\n    selectedKey,\n    setSelectedKey,\n    selectedItem\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useOverlayTriggerState} from './useOverlayTriggerState';\n\nexport type {OverlayTriggerProps} from '@react-types/overlays';\nexport type {OverlayTriggerState} from './useOverlayTriggerState';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {OverlayTriggerProps} from '@react-types/overlays';\nimport {useControlledState} from '@react-stately/utils';\n\nexport interface OverlayTriggerState {\n  /** Whether the overlay is currently open. */\n  readonly isOpen: boolean,\n  /** Sets whether the overlay is open. */\n  setOpen(isOpen: boolean): void,\n  /** Opens the overlay. */\n  open(): void,\n  /** Closes the overlay. */\n  close(): void,\n  /** Toggles the overlay's visibility. */\n  toggle(): void\n}\n\n/**\n * Manages state for an overlay trigger. Tracks whether the overlay is open, and provides\n * methods to toggle this state.\n */\nexport function useOverlayTriggerState(props: OverlayTriggerProps): OverlayTriggerState  {\n  let [isOpen, setOpen] = useControlledState(props.isOpen, props.defaultOpen || false, props.onOpenChange);\n\n  return {\n    isOpen,\n    setOpen,\n    open() {\n      setOpen(true);\n    },\n    close() {\n      setOpen(false);\n    },\n    toggle() {\n      setOpen(!isOpen);\n    }\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useMenuTriggerState} from './useMenuTriggerState';\n\nexport type {MenuTriggerProps} from '@react-types/menu';\nexport type {MenuTriggerState} from './useMenuTriggerState';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusStrategy} from '@react-types/shared';\nimport {MenuTriggerProps} from '@react-types/menu';\nimport {OverlayTriggerState, useOverlayTriggerState} from '@react-stately/overlays';\nimport {useState} from 'react';\n\nexport interface MenuTriggerState extends OverlayTriggerState {\n  /** Controls which item will be auto focused when the menu opens. */\n  readonly focusStrategy: FocusStrategy,\n\n  /** Opens the menu. */\n  open(focusStrategy?: FocusStrategy | null): void,\n\n  /** Toggles the menu. */\n  toggle(focusStrategy?: FocusStrategy | null): void\n}\n\n/**\n * Manages state for a menu trigger. Tracks whether the menu is currently open,\n * and controls which item will receive focus when it opens.\n */\nexport function useMenuTriggerState(props: MenuTriggerProps): MenuTriggerState  {\n  let overlayTriggerState = useOverlayTriggerState(props);\n  let [focusStrategy, setFocusStrategy] = useState<FocusStrategy>(null);\n\n  return {\n    focusStrategy,\n    ...overlayTriggerState,\n    open(focusStrategy: FocusStrategy = null) {\n      setFocusStrategy(focusStrategy);\n      overlayTriggerState.open();\n    },\n    toggle(focusStrategy: FocusStrategy = null) {\n      setFocusStrategy(focusStrategy);\n      overlayTriggerState.toggle();\n    }\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useComboBoxState} from './useComboBoxState';\n\nexport type {ComboBoxStateOptions, ComboBoxState} from './useComboBoxState';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, FocusStrategy, Node} from '@react-types/shared';\nimport {ComboBoxProps, MenuTriggerAction} from '@react-types/combobox';\nimport {ListCollection, useSingleSelectListState} from '@react-stately/list';\nimport {SelectState} from '@react-stately/select';\nimport {useControlledState} from '@react-stately/utils';\nimport {useEffect, useMemo, useRef, useState} from 'react';\nimport {useMenuTriggerState} from '@react-stately/menu';\n\nexport interface ComboBoxState<T> extends SelectState<T> {\n  /** The current value of the combo box input. */\n  inputValue: string,\n  /** Sets the value of the combo box input. */\n  setInputValue(value: string): void,\n  /** Selects the currently focused item and updates the input value. */\n  commit(): void,\n  /** Opens the menu. */\n  open(focusStrategy?: FocusStrategy | null, trigger?: MenuTriggerAction): void,\n  /** Toggles the menu. */\n  toggle(focusStrategy?: FocusStrategy | null, trigger?: MenuTriggerAction): void,\n  /** Resets the input value to the previously selected item's text if any and closes the menu.  */\n  revert(): void\n}\n\ntype FilterFn = (textValue: string, inputValue: string) => boolean;\n\nexport interface ComboBoxStateOptions<T> extends ComboBoxProps<T> {\n  /** The filter function used to determine if a option should be included in the combo box list. */\n  defaultFilter?: FilterFn,\n  /** Whether the combo box allows the menu to be open when the collection is empty. */\n  allowsEmptyCollection?: boolean,\n  /** Whether the combo box menu should close on blur. */\n  shouldCloseOnBlur?: boolean\n}\n\n/**\n * Provides state management for a combo box component. Handles building a collection\n * of items from props and manages the option selection state of the combo box. In addition, it tracks the input value,\n * focus state, and other properties of the combo box.\n */\nexport function useComboBoxState<T extends object>(props: ComboBoxStateOptions<T>): ComboBoxState<T> {\n  let {\n    defaultFilter,\n    menuTrigger = 'input',\n    allowsEmptyCollection = false,\n    allowsCustomValue,\n    shouldCloseOnBlur = true\n  } = props;\n\n  let [showAllItems, setShowAllItems] = useState(false);\n  let [isFocused, setFocusedState] = useState(false);\n  let [inputValue, setInputValue] = useControlledState(\n    props.inputValue,\n    props.defaultInputValue ?? '',\n    props.onInputChange\n  );\n\n  let onSelectionChange = (key) => {\n    if (props.onSelectionChange) {\n      props.onSelectionChange(key);\n    }\n\n    // If key is the same, reset the inputValue and close the menu\n    // (scenario: user clicks on already selected option)\n    if (key === selectedKey) {\n      resetInputValue();\n      triggerState.close();\n    }\n  };\n\n  let {collection, selectionManager, selectedKey, setSelectedKey, selectedItem, disabledKeys} = useSingleSelectListState({\n    ...props,\n    onSelectionChange,\n    items: props.items ?? props.defaultItems\n  });\n\n  // Preserve original collection so we can show all items on demand\n  let originalCollection = collection;\n  let filteredCollection = useMemo(() => (\n    // No default filter if items are controlled.\n    props.items != null || !defaultFilter\n      ? collection\n      : filterCollection(collection, inputValue, defaultFilter)\n  ), [collection, inputValue, defaultFilter, props.items]);\n\n  // Track what action is attempting to open the menu\n  let menuOpenTrigger = useRef('focus' as MenuTriggerAction);\n  let onOpenChange = (open: boolean) => {\n    if (props.onOpenChange) {\n      props.onOpenChange(open, open ? menuOpenTrigger.current : undefined);\n    }\n  };\n\n  let triggerState = useMenuTriggerState({...props, onOpenChange, isOpen: undefined, defaultOpen: undefined});\n  let open = (focusStrategy?: FocusStrategy, trigger?: MenuTriggerAction) => {\n    let displayAllItems = (trigger === 'manual' || (trigger === 'focus' && menuTrigger === 'focus'));\n    // Prevent open operations from triggering if there is nothing to display\n    // Also prevent open operations from triggering if items are uncontrolled but defaultItems is empty, even if displayAllItems is true.\n    // This is to prevent comboboxes with empty defaultItems from opening but allow controlled items comboboxes to open even if the inital list is empty (assumption is user will provide swap the empty list with a base list via onOpenChange returning `menuTrigger` manual)\n    if (allowsEmptyCollection || filteredCollection.size > 0 || (displayAllItems && originalCollection.size > 0) || props.items) {\n      if (displayAllItems && !triggerState.isOpen && props.items === undefined) {\n        // Show all items if menu is manually opened. Only care about this if items are undefined\n        setShowAllItems(true);\n      }\n\n      menuOpenTrigger.current = trigger;\n      triggerState.open(focusStrategy);\n    }\n  };\n\n  let toggle = (focusStrategy?: FocusStrategy, trigger?: MenuTriggerAction) => {\n    let displayAllItems = (trigger === 'manual' || (trigger === 'focus' && menuTrigger === 'focus'));\n    // If the menu is closed and there is nothing to display, early return so toggle isn't called to prevent extraneous onOpenChange\n    if (!(allowsEmptyCollection || filteredCollection.size > 0 || (displayAllItems && originalCollection.size > 0) || props.items) && !triggerState.isOpen) {\n      return;\n    }\n\n    if (displayAllItems && !triggerState.isOpen && props.items === undefined) {\n      // Show all items if menu is toggled open. Only care about this if items are undefined\n      setShowAllItems(true);\n    }\n\n    // Only update the menuOpenTrigger if menu is currently closed\n    if (!triggerState.isOpen) {\n      menuOpenTrigger.current = trigger;\n    }\n\n    triggerState.toggle(focusStrategy);\n  };\n\n  let lastValue = useRef(inputValue);\n  let resetInputValue = () => {\n    let itemText = collection.getItem(selectedKey)?.textValue ?? '';\n    lastValue.current = itemText;\n    setInputValue(itemText);\n  };\n\n  let isInitialRender = useRef(true);\n  let lastSelectedKey = useRef(props.selectedKey ?? props.defaultSelectedKey ?? null);\n  let lastSelectedKeyText = useRef(collection.getItem(selectedKey)?.textValue ?? '');\n  // intentional omit dependency array, want this to happen on every render\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEffect(() => {\n    // Open and close menu automatically when the input value changes if the input is focused,\n    // and there are items in the collection or allowEmptyCollection is true.\n    if (\n      isFocused &&\n      (filteredCollection.size > 0 || allowsEmptyCollection) &&\n      !triggerState.isOpen &&\n      inputValue !== lastValue.current &&\n      menuTrigger !== 'manual'\n    ) {\n      open(null, 'input');\n    }\n\n    // Close the menu if the collection is empty. Don't close menu if filtered collection size is 0\n    // but we are currently showing all items via button press\n    if (\n      !showAllItems &&\n      !allowsEmptyCollection &&\n      triggerState.isOpen &&\n      filteredCollection.size === 0\n    ) {\n      triggerState.close();\n    }\n\n    // Close when an item is selected.\n    if (\n      selectedKey != null &&\n      selectedKey !== lastSelectedKey.current\n    ) {\n      triggerState.close();\n    }\n\n    // Clear focused key when input value changes and display filtered collection again.\n    if (inputValue !== lastValue.current) {\n      selectionManager.setFocusedKey(null);\n      setShowAllItems(false);\n\n      // Set selectedKey to null when the user clears the input.\n      // If controlled, this is the application developer's responsibility.\n      if (inputValue === '' && (props.inputValue === undefined || props.selectedKey === undefined)) {\n        setSelectedKey(null);\n      }\n    }\n\n    // If it is the intial render and inputValue isn't controlled nor has an intial value, set input to match current selected key if any\n    if (isInitialRender.current && (props.inputValue === undefined && props.defaultInputValue === undefined)) {\n      resetInputValue();\n    }\n\n    // If the selectedKey changed, update the input value.\n    // Do nothing if both inputValue and selectedKey are controlled.\n    // In this case, it's the user's responsibility to update inputValue in onSelectionChange.\n    if (\n      selectedKey !== lastSelectedKey.current &&\n      (props.inputValue === undefined || props.selectedKey === undefined)\n    ) {\n      resetInputValue();\n    } else {\n      lastValue.current = inputValue;\n    }\n\n    // Update the inputValue if the selected item's text changes from its last tracked value.\n    // This is to handle cases where a selectedKey is specified but the items aren't available (async loading) or the selected item's text value updates.\n    // Only reset if the user isn't currently within the field so we don't erroneously modify user input.\n    // If inputValue is controlled, it is the user's responsibility to update the inputValue when items change.\n    let selectedItemText = collection.getItem(selectedKey)?.textValue ?? '';\n    if (!isFocused && selectedKey != null && props.inputValue === undefined && selectedKey === lastSelectedKey.current) {\n      if (lastSelectedKeyText.current !== selectedItemText) {\n        lastValue.current = selectedItemText;\n        setInputValue(selectedItemText);\n      }\n    }\n\n    isInitialRender.current = false;\n    lastSelectedKey.current = selectedKey;\n    lastSelectedKeyText.current = selectedItemText;\n  });\n\n  useEffect(() => {\n    // Reset focused key when the menu closes\n    if (!triggerState.isOpen) {\n      selectionManager.setFocusedKey(null);\n    }\n  }, [triggerState.isOpen, selectionManager]);\n\n  // Revert input value and close menu\n  let revert = () => {\n    if (allowsCustomValue && selectedKey == null) {\n      commitCustomValue();\n    } else {\n      commitSelection();\n    }\n  };\n\n  let commitCustomValue = () => {\n    lastSelectedKey.current = null;\n    setSelectedKey(null);\n    triggerState.close();\n  };\n\n  let commitSelection = () => {\n    // If multiple things are controlled, call onSelectionChange\n    if (props.selectedKey !== undefined && props.inputValue !== undefined) {\n      props.onSelectionChange(selectedKey);\n\n      // Stop menu from reopening from useEffect\n      let itemText = collection.getItem(selectedKey)?.textValue ?? '';\n      lastValue.current = itemText;\n      triggerState.close();\n    } else {\n      // If only a single aspect of combobox is controlled, reset input value and close menu for the user\n      resetInputValue();\n      triggerState.close();\n    }\n  };\n\n  let commit = () => {\n    if (triggerState.isOpen && selectionManager.focusedKey != null) {\n      // Reset inputValue and close menu here if the selected key is already the focused key. Otherwise\n      // fire onSelectionChange to allow the application to control the closing.\n      if (selectedKey === selectionManager.focusedKey) {\n        commitSelection();\n      } else {\n        setSelectedKey(selectionManager.focusedKey);\n      }\n    } else if (allowsCustomValue) {\n      commitCustomValue();\n    } else {\n      // Reset inputValue and close menu if no item is focused but user triggers a commit\n      commitSelection();\n    }\n  };\n\n  let setFocused = (isFocused: boolean) => {\n    if (isFocused) {\n      if (menuTrigger === 'focus') {\n        open(null, 'focus');\n      }\n    } else if (shouldCloseOnBlur) {\n      let itemText = collection.getItem(selectedKey)?.textValue ?? '';\n      if (allowsCustomValue && inputValue !== itemText) {\n        commitCustomValue();\n      } else {\n        commitSelection();\n      }\n    }\n\n    setFocusedState(isFocused);\n  };\n\n  return {\n    ...triggerState,\n    toggle,\n    open,\n    selectionManager,\n    selectedKey,\n    setSelectedKey,\n    disabledKeys,\n    isFocused,\n    setFocused,\n    selectedItem,\n    collection: showAllItems ? originalCollection : filteredCollection,\n    inputValue,\n    setInputValue,\n    commit,\n    revert\n  };\n}\n\nfunction filterCollection<T extends object>(collection: Collection<Node<T>>, inputValue: string, filter: FilterFn): Collection<Node<T>> {\n  return new ListCollection(filterNodes(collection, inputValue, filter));\n}\n\nfunction filterNodes<T>(nodes: Iterable<Node<T>>, inputValue: string, filter: FilterFn): Iterable<Node<T>> {\n  let filteredNode = [];\n  for (let node of nodes) {\n    if (node.type === 'section' && node.hasChildNodes) {\n      let filtered = filterNodes(node.childNodes, inputValue, filter);\n      if ([...filtered].length > 0) {\n        filteredNode.push({...node, childNodes: filtered});\n      }\n    } else if (node.type !== 'section' && filter(node.textValue, inputValue)) {\n      filteredNode.push({...node});\n    }\n  }\n  return filteredNode;\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useDatePickerState} from './useDatePickerState';\nexport {useDateFieldState} from './useDateFieldState';\nexport {useDateRangePickerState} from './useDateRangePickerState';\nexport {useTimeFieldState} from './useTimeFieldState';\n\nexport type {DateFieldStateOptions, DateFieldState, DateSegment, SegmentType} from './useDateFieldState';\nexport type {DatePickerStateOptions, DatePickerState} from './useDatePickerState';\nexport type {DateRangePickerStateOptions, DateRangePickerState} from './useDateRangePickerState';\nexport type {TimeFieldStateOptions} from './useTimeFieldState';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CalendarDate, DateFormatter, toCalendarDate, toCalendarDateTime} from '@internationalized/date';\nimport {DatePickerProps, DateValue, Granularity, TimeValue} from '@react-types/datepicker';\nimport {FieldOptions, getFormatOptions, getPlaceholderTime, useDefaultProps} from './utils';\nimport {isInvalid} from './utils';\nimport {OverlayTriggerState, useOverlayTriggerState} from '@react-stately/overlays';\nimport {useControlledState} from '@react-stately/utils';\nimport {useState} from 'react';\nimport {ValidationState} from '@react-types/shared';\n\nexport interface DatePickerStateOptions extends DatePickerProps<DateValue> {\n  /**\n   * Determines whether the date picker popover should close automatically when a date is selected.\n   * @default true\n   */\n  shouldCloseOnSelect?: boolean | (() => boolean)\n}\n\nexport interface DatePickerState extends OverlayTriggerState {\n  /** The currently selected date. */\n  value: DateValue,\n  /** Sets the selected date. */\n  setValue(value: DateValue): void,\n  /**\n   * The date portion of the value. This may be set prior to `value` if the user has\n   * selected a date but has not yet selected a time.\n   */\n  dateValue: DateValue,\n  /** Sets the date portion of the value. */\n  setDateValue(value: CalendarDate): void,\n  /**\n   * The time portion of the value. This may be set prior to `value` if the user has\n   * selected a time but has not yet selected a date.\n   */\n  timeValue: TimeValue,\n  /** Sets the time portion of the value. */\n  setTimeValue(value: TimeValue): void,\n  /** The granularity for the field, based on the `granularity` prop and current value. */\n  granularity: Granularity,\n  /** Whether the date picker supports selecting a time, according to the `granularity` prop and current value. */\n  hasTime: boolean,\n  /** Whether the calendar popover is currently open. */\n  isOpen: boolean,\n  /** Sets whether the calendar popover is open. */\n  setOpen(isOpen: boolean): void,\n  /** The current validation state of the date picker, based on the `validationState`, `minValue`, and `maxValue` props. */\n  validationState: ValidationState,\n  /** Formats the selected value using the given options. */\n  formatValue(locale: string, fieldOptions: FieldOptions): string\n}\n\n/**\n * Provides state management for a date picker component.\n * A date picker combines a DateField and a Calendar popover to allow users to enter or select a date and time value.\n */\nexport function useDatePickerState(props: DatePickerStateOptions): DatePickerState {\n  let overlayState = useOverlayTriggerState(props);\n  let [value, setValue] = useControlledState<DateValue>(props.value, props.defaultValue || null, props.onChange);\n\n  let v = (value || props.placeholderValue);\n  let [granularity, defaultTimeZone] = useDefaultProps(v, props.granularity);\n  let dateValue = value != null ? value.toDate(defaultTimeZone ?? 'UTC') : null;\n  let hasTime = granularity === 'hour' || granularity === 'minute' || granularity === 'second';\n  let shouldCloseOnSelect = props.shouldCloseOnSelect ?? true;\n\n  let [selectedDate, setSelectedDate] = useState<DateValue>(null);\n  let [selectedTime, setSelectedTime] = useState<TimeValue>(null);\n\n  if (value) {\n    selectedDate = value;\n    if ('hour' in value) {\n      selectedTime = value;\n    }\n  }\n\n  // props.granularity must actually exist in the value if one is provided.\n  if (v && !(granularity in v)) {\n    throw new Error('Invalid granularity ' + granularity + ' for value ' + v.toString());\n  }\n\n  let commitValue = (date: DateValue, time: TimeValue) => {\n    setValue('timeZone' in time ? time.set(toCalendarDate(date)) : toCalendarDateTime(date, time));\n  };\n\n  // Intercept setValue to make sure the Time section is not changed by date selection in Calendar\n  let selectDate = (newValue: CalendarDate) => {\n    let shouldClose = typeof shouldCloseOnSelect === 'function' ? shouldCloseOnSelect() : shouldCloseOnSelect;\n    if (hasTime) {\n      if (selectedTime || shouldClose) {\n        commitValue(newValue, selectedTime || getPlaceholderTime(props.placeholderValue));\n      } else {\n        setSelectedDate(newValue);\n      }\n    } else {\n      setValue(newValue);\n    }\n\n    if (shouldClose) {\n      overlayState.setOpen(false);\n    }\n  };\n\n  let selectTime = (newValue: TimeValue) => {\n    if (selectedDate) {\n      commitValue(selectedDate, newValue);\n    } else {\n      setSelectedTime(newValue);\n    }\n  };\n\n  let validationState: ValidationState = props.validationState ||\n    (isInvalid(value, props.minValue, props.maxValue) ? 'invalid' : null) ||\n    (value && props.isDateUnavailable?.(value) ? 'invalid' : null);\n\n  return {\n    value,\n    setValue,\n    dateValue: selectedDate,\n    timeValue: selectedTime,\n    setDateValue: selectDate,\n    setTimeValue: selectTime,\n    granularity,\n    hasTime,\n    ...overlayState,\n    setOpen(isOpen) {\n      // Commit the selected date when the calendar is closed. Use a placeholder time if one wasn't set.\n      // If only the time was set and not the date, don't commit. The state will be preserved until\n      // the user opens the popover again.\n      if (!isOpen && !value && selectedDate && hasTime) {\n        commitValue(selectedDate, selectedTime || getPlaceholderTime(props.placeholderValue));\n      }\n\n      overlayState.setOpen(isOpen);\n    },\n    validationState,\n    formatValue(locale, fieldOptions) {\n      if (!dateValue) {\n        return '';\n      }\n\n      let formatOptions = getFormatOptions(fieldOptions, {\n        granularity,\n        timeZone: defaultTimeZone,\n        hideTimeZone: props.hideTimeZone,\n        hourCycle: props.hourCycle,\n        showEra: value.calendar.identifier === 'gregory' && value.era === 'BC'\n      });\n\n      let formatter = new DateFormatter(locale, formatOptions);\n      return formatter.format(dateValue);\n    }\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Calendar, now, Time, toCalendar, toCalendarDate, toCalendarDateTime} from '@internationalized/date';\nimport {DatePickerProps, DateValue, Granularity, TimeValue} from '@react-types/datepicker';\nimport {useRef} from 'react';\n\nexport function isInvalid(value: DateValue, minValue: DateValue, maxValue: DateValue) {\n  return value != null && (\n    (minValue != null && value.compare(minValue) < 0) ||\n    (maxValue != null && value.compare(maxValue) > 0)\n  );\n}\n\nexport type FieldOptions = Pick<Intl.DateTimeFormatOptions, 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second'>;\ninterface FormatterOptions {\n  timeZone?: string,\n  hideTimeZone?: boolean,\n  granularity?: DatePickerProps<any>['granularity'],\n  maxGranularity?: 'year' | 'month' | DatePickerProps<any>['granularity'],\n  hourCycle?: 12 | 24,\n  showEra?: boolean\n}\n\nconst DEFAULT_FIELD_OPTIONS: FieldOptions = {\n  year: 'numeric',\n  month: 'numeric',\n  day: 'numeric',\n  hour: 'numeric',\n  minute: '2-digit',\n  second: '2-digit'\n};\n\nexport function getFormatOptions(\n  fieldOptions: FieldOptions,\n  options: FormatterOptions\n): Intl.DateTimeFormatOptions {\n  fieldOptions = {...DEFAULT_FIELD_OPTIONS, ...fieldOptions};\n  let granularity = options.granularity || 'minute';\n  let keys = Object.keys(fieldOptions);\n  let startIdx = keys.indexOf(options.maxGranularity ?? 'year');\n  if (startIdx < 0) {\n    startIdx = 0;\n  }\n\n  let endIdx = keys.indexOf(granularity);\n  if (endIdx < 0) {\n    endIdx = 2;\n  }\n\n  if (startIdx > endIdx) {\n    throw new Error('maxGranularity must be greater than granularity');\n  }\n\n  let opts: Intl.DateTimeFormatOptions = keys.slice(startIdx, endIdx + 1).reduce((opts, key) => {\n    opts[key] = fieldOptions[key];\n    return opts;\n  }, {});\n\n  if (options.hourCycle != null) {\n    opts.hour12 = options.hourCycle === 12;\n  }\n\n  opts.timeZone = options.timeZone || 'UTC';\n\n  let hasTime = granularity === 'hour' || granularity === 'minute' || granularity === 'second';\n  if (hasTime && options.timeZone && !options.hideTimeZone) {\n    opts.timeZoneName = 'short';\n  }\n\n  if (options.showEra && startIdx === 0) {\n    opts.era = 'short';\n  }\n\n  return opts;\n}\n\nexport function getPlaceholderTime(placeholderValue: DateValue): TimeValue {\n  if (placeholderValue && 'hour' in placeholderValue) {\n    return placeholderValue;\n  }\n\n  return new Time();\n}\n\nexport function convertValue(value: DateValue, calendar: Calendar): DateValue {\n  if (value === null) {\n    return null;\n  }\n\n  if (!value) {\n    return undefined;\n  }\n\n  return toCalendar(value, calendar);\n}\n\n\nexport function createPlaceholderDate(placeholderValue: DateValue, granularity: string, calendar: Calendar, timeZone: string) {\n  if (placeholderValue) {\n    return convertValue(placeholderValue, calendar);\n  }\n\n  let date = toCalendar(now(timeZone).set({\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0\n  }), calendar);\n\n  if (granularity === 'year' || granularity === 'month' || granularity === 'day') {\n    return toCalendarDate(date);\n  }\n\n  if (!timeZone) {\n    return toCalendarDateTime(date);\n  }\n\n  return date;\n}\n\nexport function useDefaultProps(v: DateValue, granularity: Granularity): [Granularity, string] {\n  // Compute default granularity and time zone from the value. If the value becomes null, keep the last values.\n  let lastValue = useRef(v);\n  if (v) {\n    lastValue.current = v;\n  }\n\n  v = lastValue.current;\n  let defaultTimeZone = (v && 'timeZone' in v ? v.timeZone : undefined);\n  granularity = granularity || (v && 'minute' in v ? 'minute' : 'day');\n\n  // props.granularity must actually exist in the value if one is provided.\n  if (v && !(granularity in v)) {\n    throw new Error('Invalid granularity ' + granularity + ' for value ' + v.toString());\n  }\n\n  return [granularity, defaultTimeZone];\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Calendar, DateFormatter, getMinimumDayInMonth, getMinimumMonthInYear, GregorianCalendar, toCalendar} from '@internationalized/date';\nimport {convertValue, createPlaceholderDate, FieldOptions, getFormatOptions, isInvalid, useDefaultProps} from './utils';\nimport {DatePickerProps, DateValue, Granularity} from '@react-types/datepicker';\nimport {getPlaceholder} from './placeholders';\nimport {useControlledState} from '@react-stately/utils';\nimport {useEffect, useMemo, useRef, useState} from 'react';\nimport {ValidationState} from '@react-types/shared';\n\nexport type SegmentType = 'era' | 'year' | 'month' | 'day' |  'hour' | 'minute' | 'second' | 'dayPeriod' | 'literal' | 'timeZoneName';\nexport interface DateSegment {\n  /** The type of segment. */\n  type: SegmentType,\n  /** The formatted text for the segment. */\n  text: string,\n  /** The numeric value for the segment, if applicable. */\n  value?: number,\n  /** The minimum numeric value for the segment, if applicable. */\n  minValue?: number,\n  /** The maximum numeric value for the segment, if applicable. */\n  maxValue?: number,\n  /** Whether the value is a placeholder. */\n  isPlaceholder: boolean,\n  /** A placeholder string for the segment. */\n  placeholder: string,\n  /** Whether the segment is editable. */\n  isEditable: boolean\n}\n\nexport interface DateFieldState {\n  /** The current field value. */\n  value: DateValue,\n  /** The current value, converted to a native JavaScript `Date` object.  */\n  dateValue: Date,\n  /** The calendar system currently in use. */\n  calendar: Calendar,\n  /** Sets the field's value. */\n  setValue(value: DateValue): void,\n  /** A list of segments for the current value. */\n  segments: DateSegment[],\n  /** A date formatter configured for the current locale and format. */\n  dateFormatter: DateFormatter,\n  /** The current validation state of the date field, based on the `validationState`, `minValue`, and `maxValue` props. */\n  validationState: ValidationState,\n  /** The granularity for the field, based on the `granularity` prop and current value. */\n  granularity: Granularity,\n  /** The maximum date or time unit that is displayed in the field. */\n  maxGranularity: 'year' | 'month' | Granularity,\n  /** Whether the field is disabled. */\n  isDisabled: boolean,\n  /** Whether the field is read only. */\n  isReadOnly: boolean,\n  /** Whether the field is required. */\n  isRequired: boolean,\n  /** Increments the given segment. Upon reaching the minimum or maximum value, the value wraps around to the opposite limit. */\n  increment(type: SegmentType): void,\n  /** Decrements the given segment. Upon reaching the minimum or maximum value, the value wraps around to the opposite limit. */\n  decrement(type: SegmentType): void,\n  /**\n   * Increments the given segment by a larger amount, rounding it to the nearest increment.\n   * The amount to increment by depends on the field, for example 15 minutes, 7 days, and 5 years.\n   * Upon reaching the minimum or maximum value, the value wraps around to the opposite limit.\n   */\n  incrementPage(type: SegmentType): void,\n  /**\n   * Decrements the given segment by a larger amount, rounding it to the nearest increment.\n   * The amount to decrement by depends on the field, for example 15 minutes, 7 days, and 5 years.\n   * Upon reaching the minimum or maximum value, the value wraps around to the opposite limit.\n   */\n  decrementPage(type: SegmentType): void,\n  /** Sets the value of the given segment. */\n  setSegment(type: 'era', value: string): void,\n  setSegment(type: SegmentType, value: number): void,\n  /** Updates the remaining unfilled segments with the placeholder value. */\n  confirmPlaceholder(): void,\n  /** Clears the value of the given segment, reverting it to the placeholder. */\n  clearSegment(type: SegmentType): void,\n  /** Formats the current date value using the given options. */\n  formatValue(fieldOptions: FieldOptions): string\n}\n\nconst EDITABLE_SEGMENTS = {\n  year: true,\n  month: true,\n  day: true,\n  hour: true,\n  minute: true,\n  second: true,\n  dayPeriod: true,\n  era: true\n};\n\nconst PAGE_STEP = {\n  year: 5,\n  month: 2,\n  day: 7,\n  hour: 2,\n  minute: 15,\n  second: 15\n};\n\n// Node seems to convert everything to lowercase...\nconst TYPE_MAPPING = {\n  dayperiod: 'dayPeriod'\n};\n\nexport interface DateFieldStateOptions extends DatePickerProps<DateValue> {\n  /**\n   * The maximum unit to display in the date field.\n   * @default 'year'\n   */\n  maxGranularity?: 'year' | 'month' | Granularity,\n  /** The locale to display and edit the value according to. */\n  locale: string,\n  /**\n   * A function that creates a [Calendar](../internationalized/date/Calendar.html)\n   * object for a given calendar identifier. Such a function may be imported from the\n   * `@internationalized/date` package, or manually implemented to include support for\n   * only certain calendars.\n   */\n  createCalendar: (name: string) => Calendar\n}\n\n/**\n * Provides state management for a date field component.\n * A date field allows users to enter and edit date and time values using a keyboard.\n * Each part of a date value is displayed in an individually editable segment.\n */\nexport function useDateFieldState(props: DateFieldStateOptions): DateFieldState {\n  let {\n    locale,\n    createCalendar,\n    hideTimeZone,\n    isDisabled,\n    isReadOnly,\n    isRequired\n  } = props;\n\n  let v: DateValue = (props.value || props.defaultValue || props.placeholderValue);\n  let [granularity, defaultTimeZone] = useDefaultProps(v, props.granularity);\n  let timeZone = defaultTimeZone || 'UTC';\n\n  // props.granularity must actually exist in the value if one is provided.\n  if (v && !(granularity in v)) {\n    throw new Error('Invalid granularity ' + granularity + ' for value ' + v.toString());\n  }\n\n  let defaultFormatter = useMemo(() => new DateFormatter(locale), [locale]);\n  let calendar = useMemo(() => createCalendar(defaultFormatter.resolvedOptions().calendar), [createCalendar, defaultFormatter]);\n\n  let [value, setDate] = useControlledState<DateValue>(\n    props.value,\n    props.defaultValue,\n    props.onChange\n  );\n\n  let calendarValue = useMemo(() => convertValue(value, calendar), [value, calendar]);\n\n  // We keep track of the placeholder date separately in state so that onChange is not called\n  // until all segments are set. If the value === null (not undefined), then assume the component\n  // is controlled, so use the placeholder as the value until all segments are entered so it doesn't\n  // change from uncontrolled to controlled and emit a warning.\n  let [placeholderDate, setPlaceholderDate] = useState(\n    () => createPlaceholderDate(props.placeholderValue, granularity, calendar, defaultTimeZone)\n  );\n\n  let val = calendarValue || placeholderDate;\n  let showEra = calendar.identifier === 'gregory' && val.era === 'BC';\n  let formatOpts = useMemo(() => ({\n    granularity,\n    maxGranularity: props.maxGranularity ?? 'year',\n    timeZone: defaultTimeZone,\n    hideTimeZone,\n    hourCycle: props.hourCycle,\n    showEra\n  }), [props.maxGranularity, granularity, props.hourCycle, defaultTimeZone, hideTimeZone, showEra]);\n  let opts = useMemo(() => getFormatOptions({}, formatOpts), [formatOpts]);\n\n  let dateFormatter = useMemo(() => new DateFormatter(locale, opts), [locale, opts]);\n  let resolvedOptions = useMemo(() => dateFormatter.resolvedOptions(), [dateFormatter]);\n\n  // Determine how many editable segments there are for validation purposes.\n  // The result is cached for performance.\n  let allSegments: Partial<typeof EDITABLE_SEGMENTS> = useMemo(() =>\n    dateFormatter.formatToParts(new Date())\n      .filter(seg => EDITABLE_SEGMENTS[seg.type])\n      .reduce((p, seg) => (p[seg.type] = true, p), {})\n  , [dateFormatter]);\n\n  let [validSegments, setValidSegments] = useState<Partial<typeof EDITABLE_SEGMENTS>>(\n    () => props.value || props.defaultValue ? {...allSegments} : {}\n  );\n\n  // Reset placeholder when calendar changes\n  let lastCalendarIdentifier = useRef(calendar.identifier);\n  useEffect(() => {\n    if (calendar.identifier !== lastCalendarIdentifier.current) {\n      lastCalendarIdentifier.current = calendar.identifier;\n      setPlaceholderDate(placeholder =>\n        Object.keys(validSegments).length > 0\n          ? toCalendar(placeholder, calendar)\n          : createPlaceholderDate(props.placeholderValue, granularity, calendar, defaultTimeZone)\n      );\n    }\n  }, [calendar, granularity, validSegments, defaultTimeZone, props.placeholderValue]);\n\n  // If there is a value prop, and some segments were previously placeholders, mark them all as valid.\n  if (value && Object.keys(validSegments).length < Object.keys(allSegments).length) {\n    validSegments = {...allSegments};\n    setValidSegments(validSegments);\n  }\n\n  // If the value is set to null and all segments are valid, reset the placeholder.\n  if (value == null && Object.keys(validSegments).length === Object.keys(allSegments).length) {\n    validSegments = {};\n    setValidSegments(validSegments);\n    setPlaceholderDate(createPlaceholderDate(props.placeholderValue, granularity, calendar, defaultTimeZone));\n  }\n\n  // If all segments are valid, use the date from state, otherwise use the placeholder date.\n  let displayValue = calendarValue && Object.keys(validSegments).length >= Object.keys(allSegments).length ? calendarValue : placeholderDate;\n  let setValue = (newValue: DateValue) => {\n    if (props.isDisabled || props.isReadOnly) {\n      return;\n    }\n\n    if (Object.keys(validSegments).length >= Object.keys(allSegments).length) {\n      // The display calendar should not have any effect on the emitted value.\n      // Emit dates in the same calendar as the original value, if any, otherwise gregorian.\n      newValue = toCalendar(newValue, v?.calendar || new GregorianCalendar());\n      setDate(newValue);\n    } else {\n      setPlaceholderDate(newValue);\n    }\n  };\n\n  let dateValue = useMemo(() => displayValue.toDate(timeZone), [displayValue, timeZone]);\n  let segments = useMemo(() =>\n    dateFormatter.formatToParts(dateValue)\n      .map(segment => {\n        let isEditable = EDITABLE_SEGMENTS[segment.type];\n        if (segment.type === 'era' && calendar.getEras().length === 1) {\n          isEditable = false;\n        }\n\n        let isPlaceholder = EDITABLE_SEGMENTS[segment.type] && !validSegments[segment.type];\n        let placeholder = EDITABLE_SEGMENTS[segment.type] ? getPlaceholder(segment.type, segment.value, locale) : null;\n        return {\n          type: TYPE_MAPPING[segment.type] || segment.type,\n          text: isPlaceholder ? placeholder : segment.value,\n          ...getSegmentLimits(displayValue, segment.type, resolvedOptions),\n          isPlaceholder,\n          placeholder,\n          isEditable\n        } as DateSegment;\n      })\n  , [dateValue, validSegments, dateFormatter, resolvedOptions, displayValue, calendar, locale]);\n\n  // When the era field appears, mark it valid if the year field is already valid.\n  // If the era field disappears, remove it from the valid segments.\n  if (allSegments.era && validSegments.year && !validSegments.era) {\n    validSegments.era = true;\n    setValidSegments({...validSegments});\n  } else if (!allSegments.era && validSegments.era) {\n    delete validSegments.era;\n    setValidSegments({...validSegments});\n  }\n\n  let markValid = (part: Intl.DateTimeFormatPartTypes) => {\n    validSegments[part] = true;\n    if (part === 'year' && allSegments.era) {\n      validSegments.era = true;\n    }\n    setValidSegments({...validSegments});\n  };\n\n  let adjustSegment = (type: Intl.DateTimeFormatPartTypes, amount: number) => {\n    if (!validSegments[type]) {\n      markValid(type);\n      if (Object.keys(validSegments).length >= Object.keys(allSegments).length) {\n        setValue(displayValue);\n      }\n    } else {\n      setValue(addSegment(displayValue, type, amount, resolvedOptions));\n    }\n  };\n\n  let validationState: ValidationState = props.validationState ||\n    (isInvalid(calendarValue, props.minValue, props.maxValue) ? 'invalid' : null);\n\n  return {\n    value: calendarValue,\n    dateValue,\n    calendar,\n    setValue,\n    segments,\n    dateFormatter,\n    validationState,\n    granularity,\n    maxGranularity: props.maxGranularity ?? 'year',\n    isDisabled,\n    isReadOnly,\n    isRequired,\n    increment(part) {\n      adjustSegment(part, 1);\n    },\n    decrement(part) {\n      adjustSegment(part, -1);\n    },\n    incrementPage(part) {\n      adjustSegment(part, PAGE_STEP[part] || 1);\n    },\n    decrementPage(part) {\n      adjustSegment(part, -(PAGE_STEP[part] || 1));\n    },\n    setSegment(part, v) {\n      markValid(part);\n      setValue(setSegment(displayValue, part, v, resolvedOptions));\n    },\n    confirmPlaceholder() {\n      if (props.isDisabled || props.isReadOnly) {\n        return;\n      }\n\n      // Confirm the placeholder if only the day period is not filled in.\n      let validKeys = Object.keys(validSegments);\n      let allKeys = Object.keys(allSegments);\n      if (validKeys.length === allKeys.length - 1 && allSegments.dayPeriod && !validSegments.dayPeriod) {\n        validSegments = {...allSegments};\n        setValidSegments(validSegments);\n        setValue(displayValue.copy());\n      }\n    },\n    clearSegment(part) {\n      delete validSegments[part];\n      setValidSegments({...validSegments});\n\n      let placeholder = createPlaceholderDate(props.placeholderValue, granularity, calendar, defaultTimeZone);\n      let value = displayValue;\n\n      // Reset day period to default without changing the hour.\n      if (part === 'dayPeriod' && 'hour' in displayValue && 'hour' in placeholder) {\n        let isPM = displayValue.hour >= 12;\n        let shouldBePM = placeholder.hour >= 12;\n        if (isPM && !shouldBePM) {\n          value = displayValue.set({hour: displayValue.hour - 12});\n        } else if (!isPM && shouldBePM) {\n          value = displayValue.set({hour: displayValue.hour + 12});\n        }\n      } else if (part in displayValue) {\n        value = displayValue.set({[part]: placeholder[part]});\n      }\n\n      setDate(null);\n      setValue(value);\n    },\n    formatValue(fieldOptions: FieldOptions) {\n      if (!calendarValue) {\n        return '';\n      }\n\n      let formatOptions = getFormatOptions(fieldOptions, formatOpts);\n      let formatter = new DateFormatter(locale, formatOptions);\n      return formatter.format(dateValue);\n    }\n  };\n}\n\nfunction getSegmentLimits(date: DateValue, type: string, options: Intl.ResolvedDateTimeFormatOptions) {\n  switch (type) {\n    case 'era': {\n      let eras = date.calendar.getEras();\n      return {\n        value: eras.indexOf(date.era),\n        minValue: 0,\n        maxValue: eras.length - 1\n      };\n    }\n    case 'year':\n      return {\n        value: date.year,\n        minValue: 1,\n        maxValue: date.calendar.getYearsInEra(date)\n      };\n    case 'month':\n      return {\n        value: date.month,\n        minValue: getMinimumMonthInYear(date),\n        maxValue: date.calendar.getMonthsInYear(date)\n      };\n    case 'day':\n      return {\n        value: date.day,\n        minValue: getMinimumDayInMonth(date),\n        maxValue: date.calendar.getDaysInMonth(date)\n      };\n  }\n\n  if ('hour' in date) {\n    switch (type) {\n      case 'dayPeriod':\n        return {\n          value: date.hour >= 12 ? 12 : 0,\n          minValue: 0,\n          maxValue: 12\n        };\n      case 'hour':\n        if (options.hour12) {\n          let isPM = date.hour >= 12;\n          return {\n            value: date.hour,\n            minValue: isPM ? 12 : 0,\n            maxValue: isPM ? 23 : 11\n          };\n        }\n\n        return {\n          value: date.hour,\n          minValue: 0,\n          maxValue: 23\n        };\n      case 'minute':\n        return {\n          value: date.minute,\n          minValue: 0,\n          maxValue: 59\n        };\n      case 'second':\n        return {\n          value: date.second,\n          minValue: 0,\n          maxValue: 59\n        };\n    }\n  }\n\n  return {};\n}\n\nfunction addSegment(value: DateValue, part: string, amount: number, options: Intl.ResolvedDateTimeFormatOptions) {\n  switch (part) {\n    case 'era':\n    case 'year':\n    case 'month':\n    case 'day':\n      return value.cycle(part, amount, {round: part === 'year'});\n  }\n\n  if ('hour' in value) {\n    switch (part) {\n      case 'dayPeriod': {\n        let hours = value.hour;\n        let isPM = hours >= 12;\n        return value.set({hour: isPM ? hours - 12 : hours + 12});\n      }\n      case 'hour':\n      case 'minute':\n      case 'second':\n        return value.cycle(part, amount, {\n          round: part !== 'hour',\n          hourCycle: options.hour12 ? 12 : 24\n        });\n    }\n  }\n}\n\nfunction setSegment(value: DateValue, part: string, segmentValue: number, options: Intl.ResolvedDateTimeFormatOptions) {\n  switch (part) {\n    case 'day':\n    case 'month':\n    case 'year':\n    case 'era':\n      return value.set({[part]: segmentValue});\n  }\n\n  if ('hour' in value) {\n    switch (part) {\n      case 'dayPeriod': {\n        let hours = value.hour;\n        let wasPM = hours >= 12;\n        let isPM = segmentValue >= 12;\n        if (isPM === wasPM) {\n          return value;\n        }\n        return value.set({hour: wasPM ? hours - 12 : hours + 12});\n      }\n      case 'hour':\n        // In 12 hour time, ensure that AM/PM does not change\n        if (options.hour12) {\n          let hours = value.hour;\n          let wasPM = hours >= 12;\n          if (!wasPM && segmentValue === 12) {\n            segmentValue = 0;\n          }\n          if (wasPM && segmentValue < 12) {\n            segmentValue += 12;\n          }\n        }\n        // fallthrough\n      case 'minute':\n      case 'second':\n        return value.set({[part]: segmentValue});\n    }\n  }\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {LocalizedStringDictionary} from '@internationalized/string';\n\n// These placeholders are based on the strings used by the <input type=\"date\">\n// implementations in Chrome and Firefox. Additional languages are supported\n// here than React Spectrum's typical translations.\nconst placeholders = new LocalizedStringDictionary({\n  ach: {year: 'mwaka', month: 'dwe', day: 'nino'},\n  af: {year: 'jjjj', month: 'mm', day: 'dd'},\n  am: {year: '\u12D3\u12D3\u12D3\u12D3', month: '\u121A\u121C', day: '\u1240\u1240'},\n  an: {year: 'aaaa', month: 'mm', day: 'dd'},\n  ar: {year: '\u0633\u0646\u0629', month: '\u0634\u0647\u0631', day: '\u064A\u0648\u0645'},\n  ast: {year: 'aaaa', month: 'mm', day: 'dd'},\n  az: {year: 'iiii', month: 'aa', day: 'gg'},\n  be: {year: '\u0433\u0433\u0433\u0433', month: '\u043C\u043C', day: '\u0434\u0434'},\n  bg: {year: '\u0433\u0433\u0433\u0433', month: '\u043C\u043C', day: '\u0434\u0434'},\n  bn: {year: 'yyyy', month: '\u09AE\u09BF\u09AE\u09BF', day: 'dd'},\n  br: {year: 'bbbb', month: 'mm', day: 'dd'},\n  bs: {year: 'gggg', month: 'mm', day: 'dd'},\n  ca: {year: 'aaaa', month: 'mm', day: 'dd'},\n  cak: {year: 'jjjj', month: 'ii', day: \"q'q'\"},\n  ckb: {year: '\u0633\u0627\u06B5', month: '\u0645\u0627\u0646\u06AF', day: '\u0695\u06C6\u0698'},\n  cs: {year: 'rrrr', month: 'mm', day: 'dd'},\n  cy: {year: 'bbbb', month: 'mm', day: 'dd'},\n  da: {year: '\u00E5\u00E5\u00E5\u00E5', month: 'mm', day: 'dd'},\n  de: {year: 'jjjj', month: 'mm', day: 'tt'},\n  dsb: {year: 'llll', month: 'mm', day: '\u017A\u017A'},\n  el: {year: '\u03B5\u03B5\u03B5\u03B5', month: '\u03BC\u03BC', day: '\u03B7\u03B7'},\n  en: {year: 'yyyy', month: 'mm', day: 'dd'},\n  eo: {year: 'jjjj', month: 'mm', day: 'tt'},\n  es: {year: 'aaaa', month: 'mm', day: 'dd'},\n  et: {year: 'aaaa', month: 'kk', day: 'pp'},\n  eu: {year: 'uuuu', month: 'hh', day: 'ee'},\n  fa: {year: '\u0633\u0627\u0644', month: '\u0645\u0627\u0647', day: '\u0631\u0648\u0632'},\n  ff: {year: 'hhhh', month: 'll', day: '\u00F1\u00F1'},\n  fi: {year: 'vvvv', month: 'kk', day: 'pp'},\n  fr: {year: 'aaaa', month: 'mm', day: 'jj'},\n  fy: {year: 'jjjj', month: 'mm', day: 'dd'},\n  ga: {year: 'bbbb', month: 'mm', day: 'll'},\n  gd: {year: 'bbbb', month: 'mm', day: 'll'},\n  gl: {year: 'aaaa', month: 'mm', day: 'dd'},\n  he: {year: '\u05E9\u05E0\u05D4', month: '\u05D7\u05D5\u05D3\u05E9', day: '\u05D9\u05D5\u05DD'},\n  hr: {year: 'gggg', month: 'mm', day: 'dd'},\n  hsb: {year: 'llll', month: 'mm', day: 'dd'},\n  hu: {year: '\u00E9\u00E9\u00E9\u00E9', month: 'hh', day: 'nn'},\n  ia: {year: 'aaaa', month: 'mm', day: 'dd'},\n  id: {year: 'tttt', month: 'bb', day: 'hh'},\n  it: {year: 'aaaa', month: 'mm', day: 'gg'},\n  ja: {year: ' \u5E74 ', month: '\u6708', day: '\u65E5'},\n  ka: {year: '\u10EC\u10EC\u10EC\u10EC', month: '\u10D7\u10D7', day: '\u10E0\u10E0'},\n  kk: {year: '\u0436\u0436\u0436\u0436', month: '\u0430\u0430', day: '\u043A\u043A'},\n  kn: {year: '\u0CB5\u0CB5\u0CB5\u0CB5', month: '\u0CAE\u0CBF\u0CAE\u0CC0', day: '\u0CA6\u0CBF\u0CA6\u0CBF'},\n  ko: {year: '\uC5F0\uB3C4', month: '\uC6D4', day: '\uC77C'},\n  lb: {year: 'jjjj', month: 'mm', day: 'dd'},\n  lo: {year: '\u0E9B\u0E9B\u0E9B\u0E9B', month: '\u0E94\u0E94', day: '\u0EA7\u0EA7'},\n  lt: {year: 'mmmm', month: 'mm', day: 'dd'},\n  lv: {year: 'gggg', month: 'mm', day: 'dd'},\n  meh: {year: 'aaaa', month: 'mm', day: 'dd'},\n  ml: {year: '\u0D35\u0D7C\u0D37\u0D02', month: '\u0D2E\u0D3E\u0D38\u0D02', day: '\u0D24\u0D40\u0D2F\u0D24\u0D3F'},\n  ms: {year: 'tttt', month: 'mm', day: 'hh'},\n  nl: {year: 'jjjj', month: 'mm', day: 'dd'},\n  nn: {year: '\u00E5\u00E5\u00E5\u00E5', month: 'mm', day: 'dd'},\n  no: {year: '\u00E5\u00E5\u00E5\u00E5', month: 'mm', day: 'dd'},\n  oc: {year: 'aaaa', month: 'mm', day: 'jj'},\n  pl: {year: 'rrrr', month: 'mm', day: 'dd'},\n  pt: {year: 'aaaa', month: 'mm', day: 'dd'},\n  rm: {year: 'oooo', month: 'mm', day: 'dd'},\n  ro: {year: 'aaaa', month: 'll', day: 'zz'},\n  ru: {year: '\u0433\u0433\u0433\u0433', month: '\u043C\u043C', day: '\u0434\u0434'},\n  sc: {year: 'aaaa', month: 'mm', day: 'dd'},\n  scn: {year: 'aaaa', month: 'mm', day: 'jj'},\n  sk: {year: 'rrrr', month: 'mm', day: 'dd'},\n  sl: {year: 'llll', month: 'mm', day: 'dd'},\n  sr: {year: '\u0433\u0433\u0433\u0433', month: '\u043C\u043C', day: '\u0434\u0434'},\n  sv: {year: '\u00E5\u00E5\u00E5\u00E5', month: 'mm', day: 'dd'},\n  szl: {year: 'rrrr', month: 'mm', day: 'dd'},\n  tg: {year: '\u0441\u0441\u0441\u0441', month: '\u043C\u043C', day: '\u0440\u0440'},\n  th: {year: '\u0E1B\u0E1B\u0E1B\u0E1B', month: '\u0E14\u0E14', day: '\u0E27\u0E27'},\n  tr: {year: 'yyyy', month: 'aa', day: 'gg'},\n  uk: {year: '\u0440\u0440\u0440\u0440', month: '\u043C\u043C', day: '\u0434\u0434'},\n  'zh-CN': {year: '\u5E74', month: '\u6708', day: '\u65E5'},\n  'zh-TW': {year: '\u5E74', month: '\u6708', day: '\u65E5'}\n}, 'en');\n\nexport function getPlaceholder(field: string, value: string, locale: string) {\n  // Use the actual placeholder value for the era and day period fields.\n  if (field === 'era' || field === 'dayPeriod') {\n    return value;\n  }\n\n  if (field === 'year' || field === 'month' || field === 'day') {\n    return placeholders.getStringForLocale(field, locale);\n  }\n\n  // For time fields (e.g. hour, minute, etc.), use two dashes as the placeholder.\n  return '\u2013\u2013';\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DateFormatter, toCalendarDate, toCalendarDateTime} from '@internationalized/date';\nimport {DateRange, DateRangePickerProps, DateValue, Granularity, TimeValue} from '@react-types/datepicker';\nimport {FieldOptions, getFormatOptions, getPlaceholderTime, isInvalid, useDefaultProps} from './utils';\nimport {OverlayTriggerState, useOverlayTriggerState} from '@react-stately/overlays';\nimport {RangeValue, ValidationState} from '@react-types/shared';\nimport {useControlledState} from '@react-stately/utils';\nimport {useState} from 'react';\n\nexport interface DateRangePickerStateOptions extends DateRangePickerProps<DateValue> {\n  /**\n   * Determines whether the date picker popover should close automatically when a date is selected.\n   * @default true\n   */\n  shouldCloseOnSelect?: boolean | (() => boolean)\n}\n\ntype TimeRange = RangeValue<TimeValue>;\nexport interface DateRangePickerState extends OverlayTriggerState {\n  /** The currently selected date range. */\n  value: DateRange,\n  /** Sets the selected date range. */\n  setValue(value: DateRange): void,\n  /**\n   * The date portion of the selected range. This may be set prior to `value` if the user has\n   * selected a date range but has not yet selected a time range.\n   */\n  dateRange: DateRange,\n  /** Sets the date portion of the selected range. */\n  setDateRange(value: DateRange): void,\n  /**\n   * The time portion of the selected range. This may be set prior to `value` if the user has\n   * selected a time range but has not yet selected a date range.\n   */\n  timeRange: TimeRange,\n  /** Sets the time portion of the selected range. */\n  setTimeRange(value: TimeRange): void,\n  /** Sets the date portion of either the start or end of the selected range. */\n  setDate(part: 'start' | 'end', value: DateValue): void,\n  /** Sets the time portion of either the start or end of the selected range. */\n  setTime(part: 'start' | 'end', value: TimeValue): void,\n  /** Sets the date and time of either the start or end of the selected range. */\n  setDateTime(part: 'start' | 'end', value: DateValue): void,\n  /** The granularity for the field, based on the `granularity` prop and current value. */\n  granularity: Granularity,\n  /** Whether the date range picker supports selecting times, according to the `granularity` prop and current value. */\n  hasTime: boolean,\n  /** Whether the calendar popover is currently open. */\n  isOpen: boolean,\n  /** Sets whether the calendar popover is open. */\n  setOpen(isOpen: boolean): void,\n  /** The current validation state of the date picker, based on the `validationState`, `minValue`, and `maxValue` props. */\n  validationState: ValidationState,\n  /** Formats the selected range using the given options. */\n  formatValue(locale: string, fieldOptions: FieldOptions): {start: string, end: string}\n}\n\n/**\n * Provides state management for a date range picker component.\n * A date range picker combines two DateFields and a RangeCalendar popover to allow\n * users to enter or select a date and time range.\n */\nexport function useDateRangePickerState(props: DateRangePickerStateOptions): DateRangePickerState {\n  let overlayState = useOverlayTriggerState(props);\n  let [controlledValue, setControlledValue] = useControlledState<DateRange>(props.value, props.defaultValue || null, props.onChange);\n  let [placeholderValue, setPlaceholderValue] = useState(() => controlledValue || {start: null, end: null});\n\n  // Reset the placeholder if the value prop is set to null.\n  if (controlledValue == null && placeholderValue.start && placeholderValue.end) {\n    placeholderValue = {start: null, end: null};\n    setPlaceholderValue(placeholderValue);\n  }\n\n  let value = controlledValue || placeholderValue;\n\n  let setValue = (value: DateRange) => {\n    setPlaceholderValue(value);\n    if (value?.start && value.end) {\n      setControlledValue(value);\n    } else {\n      setControlledValue(null);\n    }\n  };\n\n  let v = (value?.start || value?.end || props.placeholderValue);\n  let [granularity] = useDefaultProps(v, props.granularity);\n  let hasTime = granularity === 'hour' || granularity === 'minute' || granularity === 'second';\n  let shouldCloseOnSelect = props.shouldCloseOnSelect ?? true;\n\n  let [dateRange, setSelectedDateRange] = useState<DateRange>(null);\n  let [timeRange, setSelectedTimeRange] = useState<TimeRange>(null);\n\n  if (value && value.start && value.end) {\n    dateRange = value;\n    if ('hour' in value.start) {\n      timeRange = value as TimeRange;\n    }\n  }\n\n  let commitValue = (dateRange: DateRange, timeRange: TimeRange) => {\n    setValue({\n      start: 'timeZone' in timeRange.start ? timeRange.start.set(toCalendarDate(dateRange.start)) : toCalendarDateTime(dateRange.start, timeRange.start),\n      end: 'timeZone' in timeRange.end ? timeRange.end.set(toCalendarDate(dateRange.end)) : toCalendarDateTime(dateRange.end, timeRange.end)\n    });\n  };\n\n  // Intercept setValue to make sure the Time section is not changed by date selection in Calendar\n  let setDateRange = (range: DateRange) => {\n    let shouldClose = typeof shouldCloseOnSelect === 'function' ? shouldCloseOnSelect() : shouldCloseOnSelect;\n    if (hasTime) {\n      if (shouldClose || (range.start && range.end && timeRange?.start && timeRange?.end)) {\n        commitValue(range, {\n          start: timeRange?.start || getPlaceholderTime(props.placeholderValue),\n          end: timeRange?.end || getPlaceholderTime(props.placeholderValue)\n        });\n      } else {\n        setSelectedDateRange(range);\n      }\n    } else if (range.start && range.end) {\n      setValue(range);\n    } else {\n      setSelectedDateRange(range);\n    }\n\n    if (shouldClose) {\n      overlayState.setOpen(false);\n    }\n  };\n\n  let setTimeRange = (range: TimeRange) => {\n    if (dateRange?.start && dateRange?.end && range.start && range.end) {\n      commitValue(dateRange, range);\n    } else {\n      setSelectedTimeRange(range);\n    }\n  };\n\n  let validationState: ValidationState = props.validationState\n    || (value != null && (\n      isInvalid(value.start, props.minValue, props.maxValue) ||\n      isInvalid(value.end, props.minValue, props.maxValue) ||\n      (value.end != null && value.start != null && value.end.compare(value.start) < 0) ||\n      (value?.start && props.isDateUnavailable?.(value.start)) ||\n      (value?.end && props.isDateUnavailable?.(value.end))\n    ) ? 'invalid' : null);\n\n  return {\n    value,\n    setValue,\n    dateRange,\n    timeRange,\n    granularity,\n    hasTime,\n    setDate(part, date) {\n      setDateRange({...dateRange, [part]: date});\n    },\n    setTime(part, time) {\n      setTimeRange({...timeRange, [part]: time});\n    },\n    setDateTime(part, dateTime) {\n      setValue({...value, [part]: dateTime});\n    },\n    setDateRange,\n    setTimeRange,\n    ...overlayState,\n    setOpen(isOpen) {\n      // Commit the selected date range when the calendar is closed. Use a placeholder time if one wasn't set.\n      // If only the time range was set and not the date range, don't commit. The state will be preserved until\n      // the user opens the popover again.\n      if (!isOpen && !(value?.start && value?.end) && dateRange?.start && dateRange?.end && hasTime) {\n        commitValue(dateRange, {\n          start: timeRange?.start || getPlaceholderTime(props.placeholderValue),\n          end: timeRange?.end || getPlaceholderTime(props.placeholderValue)\n        });\n      }\n\n      overlayState.setOpen(isOpen);\n    },\n    validationState,\n    formatValue(locale, fieldOptions) {\n      if (!value || !value.start || !value.end) {\n        return null;\n      }\n\n      let startTimeZone = 'timeZone' in value.start ? value.start.timeZone : undefined;\n      let startGranularity = props.granularity || (value.start && 'minute' in value.start ? 'minute' : 'day');\n      let endTimeZone = 'timeZone' in value.end ? value.end.timeZone : undefined;\n      let endGranularity = props.granularity || (value.end && 'minute' in value.end ? 'minute' : 'day');\n\n      let startOptions = getFormatOptions(fieldOptions, {\n        granularity: startGranularity,\n        timeZone: startTimeZone,\n        hideTimeZone: props.hideTimeZone,\n        hourCycle: props.hourCycle,\n        showEra: (value.start.calendar.identifier === 'gregory' && value.start.era === 'BC') ||\n          (value.end.calendar.identifier === 'gregory' && value.end.era === 'BC')\n      });\n\n      let startDate = value.start.toDate(startTimeZone || 'UTC');\n      let endDate = value.end.toDate(endTimeZone || 'UTC');\n\n      let startFormatter = new DateFormatter(locale, startOptions);\n      let endFormatter: Intl.DateTimeFormat;\n      if (startTimeZone === endTimeZone && startGranularity === endGranularity && value.start.compare(value.end) !== 0) {\n        // Use formatRange, as it results in shorter output when some of the fields\n        // are shared between the start and end dates (e.g. the same month).\n        // Formatting will fail if the end date is before the start date. Fall back below when that happens.\n        try {\n          let parts = startFormatter.formatRangeToParts(startDate, endDate);\n\n          // Find the separator between the start and end date. This is determined\n          // by finding the last shared literal before the end range.\n          let separatorIndex = -1;\n          for (let i = 0; i < parts.length; i++) {\n            let part = parts[i];\n            if (part.source === 'shared' && part.type === 'literal') {\n              separatorIndex = i;\n            } else if (part.source === 'endRange') {\n              break;\n            }\n          }\n\n          // Now we can combine the parts into start and end strings.\n          let start = '';\n          let end = '';\n          for (let i = 0; i < parts.length; i++) {\n            if (i < separatorIndex) {\n              start += parts[i].value;\n            } else if (i > separatorIndex) {\n              end += parts[i].value;\n            }\n          }\n\n          return {start, end};\n        } catch (e) {\n          // ignore\n        }\n\n        endFormatter = startFormatter;\n      } else {\n        let endOptions = getFormatOptions(fieldOptions, {\n          granularity: endGranularity,\n          timeZone: endTimeZone,\n          hideTimeZone: props.hideTimeZone,\n          hourCycle: props.hourCycle\n        });\n\n        endFormatter = new DateFormatter(locale, endOptions);\n      }\n\n      return {\n        start: startFormatter.format(startDate),\n        end: endFormatter.format(endDate)\n      };\n    }\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DateFieldState, useDateFieldState} from '.';\nimport {DateValue, TimePickerProps, TimeValue} from '@react-types/datepicker';\nimport {getLocalTimeZone, GregorianCalendar, Time, toCalendarDateTime, today, toTime} from '@internationalized/date';\nimport {useControlledState} from '@react-stately/utils';\nimport {useMemo} from 'react';\n\nexport interface TimeFieldStateOptions extends TimePickerProps<TimeValue> {\n  /** The locale to display and edit the value according to. */\n  locale: string\n}\n\n/**\n * Provides state management for a time field component.\n * A time field allows users to enter and edit time values using a keyboard.\n * Each part of a time value is displayed in an individually editable segment.\n */\nexport function useTimeFieldState(props: TimeFieldStateOptions): DateFieldState {\n  let {\n    placeholderValue = new Time(),\n    minValue,\n    maxValue,\n    granularity\n  } = props;\n\n  let [value, setValue] = useControlledState<TimeValue>(\n    props.value,\n    props.defaultValue,\n    props.onChange\n  );\n\n  let v = value || placeholderValue;\n  let day = v && 'day' in v ? v : undefined;\n  let placeholderDate = useMemo(() => convertValue(placeholderValue), [placeholderValue]);\n  let minDate = useMemo(() => convertValue(minValue, day), [minValue, day]);\n  let maxDate = useMemo(() => convertValue(maxValue, day), [maxValue, day]);\n\n  let dateTime = useMemo(() => value == null ? null : convertValue(value), [value]);\n  let onChange = newValue => {\n    setValue(v && 'day' in v ? newValue : newValue && toTime(newValue));\n  };\n\n  return useDateFieldState({\n    ...props,\n    value: dateTime,\n    defaultValue: undefined,\n    minValue: minDate,\n    maxValue: maxDate,\n    onChange,\n    granularity: granularity || 'minute',\n    maxGranularity: 'hour',\n    placeholderValue: placeholderDate,\n    // Calendar should not matter for time fields.\n    createCalendar: () => new GregorianCalendar()\n  });\n}\n\nfunction convertValue(value: TimeValue, date: DateValue = today(getLocalTimeZone())) {\n  if (!value) {\n    return null;\n  }\n\n  if ('day' in value) {\n    return value;\n  }\n\n  return toCalendarDateTime(date, value);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useAsyncList} from './useAsyncList';\nexport {useTreeData} from './useTreeData';\nexport {useListData} from './useListData';\n\nexport type {ListOptions, ListData} from './useListData';\nexport type {AsyncListOptions, AsyncListData} from './useAsyncList';\nexport type {TreeOptions, TreeData} from './useTreeData';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {createListActions, ListData, ListState} from './useListData';\nimport {Key, Reducer, useEffect, useReducer} from 'react';\nimport {LoadingState, Selection, SortDescriptor} from '@react-types/shared';\n\nexport interface AsyncListOptions<T, C> {\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: Iterable<Key>,\n  /** The initial sort descriptor. */\n  initialSortDescriptor?: SortDescriptor,\n  /** The initial filter text. */\n  initialFilterText?: string,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that loads the data for the items in the list. */\n  load: AsyncListLoadFunction<T, C>,\n  /**\n   * An optional function that performs sorting. If not provided,\n   * then `sortDescriptor` is passed to the `load` function.\n   */\n  sort?: AsyncListLoadFunction<T, C>\n}\n\ntype AsyncListLoadFunction<T, C> = (state: AsyncListLoadOptions<T, C>) => AsyncListStateUpdate<T, C> | Promise<AsyncListStateUpdate<T, C>>;\n\ninterface AsyncListLoadOptions<T, C> {\n  /** The items currently in the list. */\n  items: T[],\n  /** The keys of the currently selected items in the list. */\n  selectedKeys: Selection,\n  /** The current sort descriptor for the list. */\n  sortDescriptor: SortDescriptor,\n  /** An abort signal used to notify the load function that the request has been aborted. */\n  signal: AbortSignal,\n  /** The pagination cursor returned from the last page load. */\n  cursor?: C,\n  /** The current filter text used to perform server side filtering. */\n  filterText?: string,\n  /** The current loading state of the list. */\n  loadingState?: LoadingState\n}\n\ninterface AsyncListStateUpdate<T, C> {\n  /** The new items to append to the list. */\n  items: Iterable<T>,\n  /** The keys to add to the selection. */\n  selectedKeys?: Iterable<Key>,\n  /** The sort descriptor to set. */\n  sortDescriptor?: SortDescriptor,\n  /** The pagination cursor to be used for the next page load. */\n  cursor?: C,\n  /** The updated filter text for the list. */\n  filterText?: string\n}\n\ninterface AsyncListState<T, C> extends ListState<T> {\n  state: LoadingState,\n  items: T[],\n  // disabledKeys?: Iterable<Key>,\n  selectedKeys: Selection,\n  // selectedKey?: Key,\n  // expandedKeys?: Iterable<Key>,\n  sortDescriptor?: SortDescriptor,\n  error?: Error,\n  abortController?: AbortController,\n  cursor?: C\n}\n\ntype ActionType = 'success' | 'error' | 'loading' | 'loadingMore' | 'sorting' | 'update' | 'filtering';\ninterface Action<T, C> {\n  type: ActionType,\n  items?: Iterable<T>,\n  selectedKeys?: Iterable<Key>,\n  sortDescriptor?: SortDescriptor,\n  error?: Error,\n  abortController?: AbortController,\n  updater?: (state: ListState<T>) => ListState<T>,\n  cursor?: C,\n  filterText?: string\n}\n\nexport interface AsyncListData<T> extends ListData<T> {\n  /** Whether data is currently being loaded. */\n  isLoading: boolean,\n  /** If loading data failed, then this contains the error that occurred. */\n  error?: Error,\n  // disabledKeys?: Set<Key>,\n  // selectedKey?: Key,\n  // expandedKeys?: Set<Key>,\n  /** The current sort descriptor for the list. */\n  sortDescriptor?: SortDescriptor,\n\n  /** Reloads the data in the list. */\n  reload(): void,\n  /** Loads the next page of data in the list. */\n  loadMore(): void,\n  /** Triggers sorting for the list. */\n  sort(descriptor: SortDescriptor): void,\n  /** The current loading state for the list. */\n  loadingState: LoadingState\n}\n\nfunction reducer<T, C>(data: AsyncListState<T, C>, action: Action<T, C>): AsyncListState<T, C> {\n  let selectedKeys;\n  switch (data.state) {\n    case 'idle':\n    case 'error':\n      switch (action.type) {\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: action.abortController\n          };\n        case 'update':\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        case 'success':\n        case 'error':\n          return data;\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loading':\n    case 'sorting':\n    case 'filtering':\n      switch (action.type) {\n        case 'success':\n          // Ignore if there is a newer abortcontroller in state.\n          // This means that multiple requests were going at once.\n          // We want to take only the latest result.\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          selectedKeys = action.selectedKeys ?? data.selectedKeys;\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: 'idle',\n            items: [...action.items],\n            selectedKeys: selectedKeys === 'all' ? 'all' : new Set(selectedKeys),\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return {\n            ...data,\n            state: 'error',\n            error: action.error,\n            abortController: null\n          };\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading, and another load was triggered at the same time.\n          // We need to abort the previous load and start a new one.\n          data.abortController.abort();\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loadingMore':\n      switch (action.type) {\n        case 'success':\n          selectedKeys = (data.selectedKeys === 'all' || action.selectedKeys === 'all')\n            ? 'all'\n            : new Set([...data.selectedKeys, ...(action.selectedKeys ?? [])]);\n          // Append the new items\n          return {\n            ...data,\n            state: 'idle',\n            items: [...data.items, ...action.items],\n            selectedKeys,\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return {\n            ...data,\n            state: 'error',\n            error: action.error\n          };\n        case 'loading':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading more, and another load was triggered at the same time.\n          // We need to abort the previous load more and start a new one.\n          data.abortController.abort();\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'loadingMore':\n          // If already loading more and another loading more is triggered, abort the new load more since\n          // it is a duplicate request since the cursor hasn't been updated.\n          // Do not overwrite the data.abortController\n          action.abortController.abort();\n\n          return data;\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    default:\n      throw new Error(`Invalid state \"${data.state}\"`);\n  }\n}\n\n/**\n * Manages state for an immutable async loaded list data structure, and provides convenience methods to\n * update the data over time. Manages loading and error states, pagination, and sorting.\n */\nexport function useAsyncList<T, C = string>(options: AsyncListOptions<T, C>): AsyncListData<T> {\n  const {\n    load,\n    sort,\n    initialSelectedKeys,\n    initialSortDescriptor,\n    getKey = (item: any) => item.id || item.key,\n    initialFilterText = ''\n  } = options;\n\n  let [data, dispatch] = useReducer<Reducer<AsyncListState<T, C>, Action<T, C>>>(reducer, {\n    state: 'idle',\n    error: null,\n    items: [],\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys),\n    sortDescriptor: initialSortDescriptor,\n    filterText: initialFilterText\n  });\n\n  const dispatchFetch = async (action: Action<T, C>, fn: AsyncListLoadFunction<T, C>) => {\n    let abortController = new AbortController();\n    try {\n      dispatch({...action, abortController});\n      let previousFilterText = action.filterText ?? data.filterText;\n\n      let response = await fn({\n        items: data.items.slice(),\n        selectedKeys: data.selectedKeys,\n        sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n        signal: abortController.signal,\n        cursor: action.type === 'loadingMore' ? data.cursor : null,\n        filterText: previousFilterText\n      });\n\n      let filterText = response.filterText ?? previousFilterText;\n      dispatch({type: 'success', ...response, abortController});\n\n      // Fetch a new filtered list if filterText is updated via `load` response func rather than list.setFilterText\n      // Only do this if not aborted (e.g. user triggers another filter action before load completes)\n      if (filterText && (filterText !== previousFilterText) && !abortController.signal.aborted) {\n        dispatchFetch({type: 'filtering', filterText}, load);\n      }\n    } catch (e) {\n      dispatch({type: 'error', error: e, abortController});\n    }\n  };\n\n  useEffect(() => {\n    dispatchFetch({type: 'loading'}, load);\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return {\n    items: data.items,\n    selectedKeys: data.selectedKeys,\n    sortDescriptor: data.sortDescriptor,\n    isLoading: data.state === 'loading' || data.state === 'loadingMore' || data.state === 'sorting' || data.state === 'filtering',\n    loadingState: data.state,\n    error: data.error,\n    filterText: data.filterText,\n    getItem(key: Key) {\n      return data.items.find(item => getKey(item) === key);\n    },\n    reload() {\n      dispatchFetch({type: 'loading'}, load);\n    },\n    loadMore() {\n      // Ignore if already loading more or if performing server side filtering.\n      if (data.state === 'loadingMore' || data.state === 'filtering' || data.cursor == null) {\n        return;\n      }\n\n      dispatchFetch({type: 'loadingMore'}, load);\n    },\n    sort(sortDescriptor: SortDescriptor) {\n      dispatchFetch({type: 'sorting', sortDescriptor}, sort || load);\n    },\n    ...createListActions({...options, getKey, cursor: data.cursor}, fn => {\n      dispatch({type: 'update', updater: fn});\n    }),\n    setFilterText(filterText: string) {\n      dispatchFetch({type: 'filtering', filterText}, load);\n    }\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key, useMemo, useState} from 'react';\nimport {Selection} from '@react-types/shared';\n\nexport interface ListOptions<T> {\n  /** Initial items in the list. */\n  initialItems?: T[],\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: 'all' | Iterable<Key>,\n  /** The initial text to filter the list by. */\n  initialFilterText?: string,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that returns whether a item matches the current filter text. */\n  filter?: (item: T, filterText: string) => boolean\n}\n\nexport interface ListData<T> {\n  /** The items in the list. */\n  items: T[],\n\n  /** The keys of the currently selected items in the list. */\n  selectedKeys: Selection,\n\n  /** Sets the selected keys. */\n  setSelectedKeys(keys: Selection): void,\n\n  /** The current filter text. */\n  filterText: string,\n\n  /** Sets the filter text. */\n  setFilterText(filterText: string): void,\n\n  /**\n   * Gets an item from the list by key.\n   * @param key - The key of the item to retrieve.\n   */\n  getItem(key: Key): T,\n\n  /**\n   * Inserts items into the list at the given index.\n   * @param index - The index to insert into.\n   * @param values - The values to insert.\n   */\n  insert(index: number, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list before the item at the given key.\n   * @param key - The key of the item to insert before.\n   * @param values - The values to insert.\n   */\n  insertBefore(key: Key, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list after the item at the given key.\n   * @param key - The key of the item to insert after.\n   * @param values - The values to insert.\n   */\n  insertAfter(key: Key, ...values: T[]): void,\n\n  /**\n   * Appends items to the list.\n   * @param values - The values to insert.\n   */\n  append(...values: T[]): void,\n\n  /**\n   * Prepends items to the list.\n   * @param value - The value to insert.\n   */\n  prepend(...values: T[]): void,\n\n  /**\n   * Removes items from the list by their keys.\n   * @param keys - The keys of the item to remove.\n   */\n  remove(...keys: Key[]): void,\n\n  /**\n   * Removes all items from the list that are currently\n   * in the set of selected items.\n   */\n  removeSelectedItems(): void,\n\n  /**\n   * Moves an item within the list.\n   * @param key - The key of the item to move.\n   * @param toIndex - The index to move the item to.\n   */\n  move(key: Key, toIndex: number): void,\n\n  /**\n   * Moves one or more items before a given key.\n   * @param key - The key of the item to move the items before.\n   * @param keys - The keys of the items to move.\n   */\n  moveBefore(key: Key, keys: Iterable<Key>): void,\n\n  /**\n   * Moves one or more items after a given key.\n   * @param key - The key of the item to move the items after.\n   * @param keys - The keys of the items to move.\n   */\n  moveAfter(key: Key, keys: Iterable<Key>): void,\n\n  /**\n   * Updates an item in the list.\n   * @param key - The key of the item to update.\n   * @param newValue - The new value for the item.\n   */\n  update(key: Key, newValue: T): void\n}\n\nexport interface ListState<T> {\n  items: T[],\n  selectedKeys: Selection,\n  filterText: string\n}\n\ninterface CreateListOptions<T, C> extends ListOptions<T> {\n  cursor?: C\n}\n\n/**\n * Manages state for an immutable list data structure, and provides convenience methods to\n * update the data over time.\n */\nexport function useListData<T>(options: ListOptions<T>): ListData<T> {\n  let {\n    initialItems = [],\n    initialSelectedKeys,\n    getKey = (item: any) => item.id || item.key,\n    filter,\n    initialFilterText = ''\n  } = options;\n\n  // Store both items and filteredItems in state so we can go back to the unfiltered list\n  let [state, setState] = useState<ListState<T>>({\n    items: initialItems,\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys || []),\n    filterText: initialFilterText\n  });\n\n  let filteredItems = useMemo(\n    () => filter ? state.items.filter(item => filter(item, state.filterText)) : state.items,\n    [state.items, state.filterText, filter]);\n\n  return {\n    ...state,\n    items: filteredItems,\n    ...createListActions({getKey}, setState),\n    getItem(key: Key) {\n      return state.items.find(item => getKey(item) === key);\n    }\n  };\n}\n\nexport function createListActions<T, C>(opts: CreateListOptions<T, C>, dispatch: (updater: (state: ListState<T>) => ListState<T>) => void): Omit<ListData<T>, 'items' | 'selectedKeys' | 'getItem' | 'filterText'> {\n  let {cursor, getKey} = opts;\n  return {\n    setSelectedKeys(selectedKeys: Selection) {\n      dispatch(state => ({\n        ...state,\n        selectedKeys\n      }));\n    },\n    setFilterText(filterText: string) {\n      dispatch(state => ({\n        ...state,\n        filterText\n      }));\n    },\n    insert(index: number, ...values: T[]) {\n      dispatch(state => insert(state, index, ...values));\n    },\n    insertBefore(key: Key, ...values: T[]) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return;\n        }\n\n        return insert(state, index, ...values);\n      });\n    },\n    insertAfter(key: Key, ...values: T[]) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return;\n        }\n\n        return insert(state, index + 1, ...values);\n      });\n    },\n    prepend(...values: T[]) {\n      dispatch(state => insert(state, 0, ...values));\n    },\n    append(...values: T[]) {\n      dispatch(state => insert(state, state.items.length, ...values));\n    },\n    remove(...keys: Key[]) {\n      dispatch(state => {\n        let keySet = new Set(keys);\n        let items = state.items.filter(item => !keySet.has(getKey(item)));\n\n        let selection: Selection = 'all';\n        if (state.selectedKeys !== 'all') {\n          selection = new Set(state.selectedKeys);\n          for (let key of keys) {\n            selection.delete(key);\n          }\n        }\n        if (cursor == null && items.length === 0) {\n          selection = new Set();\n        }\n\n        return {\n          ...state,\n          items,\n          selectedKeys: selection\n        };\n      });\n    },\n    removeSelectedItems() {\n      dispatch(state => {\n        if (state.selectedKeys === 'all') {\n          return {\n            ...state,\n            items: [],\n            selectedKeys: new Set()\n          };\n        }\n\n        let selectedKeys = state.selectedKeys;\n        let items = state.items.filter(item => !selectedKeys.has(getKey(item)));\n        return {\n          ...state,\n          items,\n          selectedKeys: new Set()\n        };\n      });\n    },\n    move(key: Key, toIndex: number) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return state;\n        }\n\n        let copy = state.items.slice();\n        let [item] = copy.splice(index, 1);\n        copy.splice(toIndex, 0, item);\n        return {\n          ...state,\n          items: copy\n        };\n      });\n    },\n    moveBefore(key: Key, keys: Iterable<Key>) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key);\n        if (toIndex === -1) {\n          return state;\n        }\n\n        // Find indices of keys to move. Sort them so that the order in the list is retained.\n        let keyArray = Array.isArray(keys) ? keys : [...keys];\n        let indices = keyArray.map(key => state.items.findIndex(item => getKey(item) === key)).sort();\n        return move(state, indices, toIndex);\n      });\n    },\n    moveAfter(key: Key, keys: Iterable<Key>) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key);\n        if (toIndex === -1) {\n          return state;\n        }\n\n        let keyArray = Array.isArray(keys) ? keys : [...keys];\n        let indices = keyArray.map(key => state.items.findIndex(item => getKey(item) === key)).sort();\n        return move(state, indices, toIndex + 1);\n      });\n    },\n    update(key: Key, newValue: T) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return state;\n        }\n\n        return {\n          ...state,\n          items: [\n            ...state.items.slice(0, index),\n            newValue,\n            ...state.items.slice(index + 1)\n          ]\n        };\n      });\n    }\n  };\n}\n\nfunction insert<T>(state: ListState<T>, index: number, ...values: T[]): ListState<T> {\n  return {\n    ...state,\n    items: [\n      ...state.items.slice(0, index),\n      ...values,\n      ...state.items.slice(index)\n    ]\n  };\n}\n\nfunction move<T>(state: ListState<T>, indices: number[], toIndex: number): ListState<T> {\n  // Shift the target down by the number of items being moved from before the target\n  for (let index of indices) {\n    if (index < toIndex) {\n      toIndex--;\n    }\n  }\n\n  let moves = indices.map(from => ({\n    from,\n    to: toIndex++\n  }));\n\n  // Shift later from indices down if they have a larger index\n  for (let i = 0; i < moves.length; i++) {\n    let a = moves[i].from;\n    for (let j = i; j < moves.length; j++) {\n      let b = moves[j].from;\n\n      if (b > a) {\n        moves[j].from--;\n      }\n    }\n  }\n\n  // Interleave the moves so they can be applied one by one rather than all at once\n  for (let i = 0; i < moves.length; i++) {\n    let a = moves[i];\n    for (let j = moves.length - 1; j > i; j--) {\n      let b = moves[j];\n\n      if (b.from < a.to) {\n        a.to++;\n      } else {\n        b.from++;\n      }\n    }\n  }\n\n  let copy = state.items.slice();\n  for (let move of moves) {\n    let [item] = copy.splice(move.from, 1);\n    copy.splice(move.to, 0, item);\n  }\n\n  return {\n    ...state,\n    items: copy\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key, useMemo, useState} from 'react';\n\nexport interface TreeOptions<T extends object> {\n  /** Initial root items in the tree. */\n  initialItems?: T[],\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: Iterable<Key>,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that returns the children for an item object. */\n  getChildren?: (item: T) => T[]\n}\n\ninterface TreeNode<T extends object> {\n  /** A unique key for the tree node. */\n  key: Key,\n  /** The key of the parent node. */\n  parentKey: Key,\n  /** The value object for the tree node. */\n  value: T,\n  /** Children of the tree node. */\n  children: TreeNode<T>[]\n}\n\nexport interface TreeData<T extends object> {\n  /** The root nodes in the tree. */\n  items: TreeNode<T>[],\n\n  /** The keys of the currently selected items in the tree. */\n  selectedKeys: Set<Key>,\n\n  /** Sets the selected keys. */\n  setSelectedKeys(keys: Set<Key>): void,\n\n  /**\n   * Gets a node from the tree by key.\n   * @param key - The key of the item to retrieve.\n   */\n  getItem(key: Key): TreeNode<T>,\n\n  /**\n   * Inserts an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param index - The index within the parent to insert into.\n   * @param value - The value to insert.\n   */\n  insert(parentKey: Key | null, index: number, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list before the item at the given key.\n   * @param key - The key of the item to insert before.\n   * @param values - The values to insert.\n   */\n  insertBefore(key: Key, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list after the item at the given key.\n   * @param key - The key of the item to insert after.\n   * @param values - The values to insert.\n   */\n  insertAfter(key: Key, ...values: T[]): void,\n\n  /**\n   * Appends an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param value - The value to insert.\n   */\n  append(parentKey: Key | null, ...values: T[]): void,\n\n  /**\n   * Prepends an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param value - The value to insert.\n   */\n  prepend(parentKey: Key | null, ...value: T[]): void,\n\n  /**\n   * Removes an item from the tree by its key.\n   * @param key - The key of the item to remove.\n   */\n  remove(...keys: Key[]): void,\n\n  /**\n   * Removes all items from the tree that are currently\n   * in the set of selected items.\n   */\n  removeSelectedItems(): void,\n\n  /**\n   * Moves an item within the tree.\n   * @param key - The key of the item to move.\n   * @param toParentKey - The key of the new parent to insert into.\n   * @param index - The index within the new parent to insert at.\n   */\n  move(key: Key, toParentKey: Key, index: number): void,\n\n  /**\n   * Updates an item in the tree.\n   * @param key - The key of the item to update.\n   * @param newValue - The new value for the item.\n   */\n  update(key: Key, newValue: T): void\n}\n\n/**\n * Manages state for an immutable tree data structure, and provides convenience methods to\n * update the data over time.\n */\nexport function useTreeData<T extends object>(options: TreeOptions<T>): TreeData<T> {\n  let {\n    initialItems = [],\n    initialSelectedKeys,\n    getKey = (item: any) => item.id || item.key,\n    getChildren = (item: any) => item.children\n  } = options;\n  let map = useMemo(() => new Map<Key, TreeNode<T>>(), []);\n\n  // We only want to compute this on initial render.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  let initialNodes = useMemo(() => buildTree(initialItems), []);\n  let [items, setItems] = useState(initialNodes);\n  let [selectedKeys, setSelectedKeys] = useState(new Set<Key>(initialSelectedKeys || []));\n\n  function buildTree(initialItems: T[] = [], parentKey?: Key | null) {\n    return initialItems.map(item => {\n      let node: TreeNode<T> = {\n        key: getKey(item),\n        parentKey: parentKey,\n        value: item,\n        children: null\n      };\n\n      node.children = buildTree(getChildren(item), node.key);\n      map.set(node.key, node);\n      return node;\n    });\n  }\n\n  function updateTree(items: TreeNode<T>[], key: Key, update: (node: TreeNode<T>) => TreeNode<T>) {\n    let node = map.get(key);\n    if (!node) {\n      return items;\n    }\n\n    // Create a new node. If null, then delete the node, otherwise replace.\n    let newNode = update(node);\n    if (newNode == null) {\n      deleteNode(node);\n    } else {\n      addNode(newNode);\n    }\n\n    // Walk up the tree and update each parent to refer to the new chilren.\n    while (node.parentKey) {\n      let nextParent = map.get(node.parentKey);\n      let copy: TreeNode<T> = {\n        key: nextParent.key,\n        parentKey: nextParent.parentKey,\n        value: nextParent.value,\n        children: null\n      };\n\n      let children = nextParent.children;\n      if (newNode == null) {\n        children = children.filter(c => c !== node);\n      }\n\n      copy.children = children.map(child => {\n        if (child === node) {\n          return newNode;\n        }\n\n        return child;\n      });\n\n      map.set(copy.key, copy);\n\n      newNode = copy;\n      node = nextParent;\n    }\n\n    if (newNode == null) {\n      items = items.filter(c => c !== node);\n    }\n\n    return items.map(item => {\n      if (item === node) {\n        return newNode;\n      }\n\n      return item;\n    });\n  }\n\n  function addNode(node: TreeNode<T>) {\n    map.set(node.key, node);\n    for (let child of node.children) {\n      addNode(child);\n    }\n  }\n\n  function deleteNode(node: TreeNode<T>) {\n    map.delete(node.key);\n    for (let child of node.children) {\n      deleteNode(child);\n    }\n  }\n\n  return {\n    items,\n    selectedKeys,\n    setSelectedKeys,\n    getItem(key: Key) {\n      return map.get(key);\n    },\n    insert(parentKey: Key | null, index: number, ...values: T[]) {\n      setItems(items => {\n        let nodes = buildTree(values, parentKey);\n\n        // If parentKey is null, insert into the root.\n        if (parentKey == null) {\n          return [\n            ...items.slice(0, index),\n            ...nodes,\n            ...items.slice(index)\n          ];\n        }\n\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(items, parentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [\n            ...parentNode.children.slice(0, index),\n            ...nodes,\n            ...parentNode.children.slice(index)\n          ]\n        }));\n      });\n    },\n    insertBefore(key: Key, ...values: T[]): void {\n      let node = map.get(key);\n      if (!node) {\n        return;\n      }\n\n      let parentNode = map.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      this.insert(parentNode?.key, index, ...values);\n    },\n    insertAfter(key: Key, ...values: T[]): void {\n      let node = map.get(key);\n      if (!node) {\n        return;\n      }\n\n      let parentNode = map.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      this.insert(parentNode?.key, index + 1, ...values);\n    },\n    prepend(parentKey: Key | null, ...values: T[]) {\n      this.insert(parentKey, 0, ...values);\n    },\n    append(parentKey: Key | null, ...values: T[]) {\n      if (parentKey == null) {\n        this.insert(null, items.length, ...values);\n      } else {\n        let parentNode = map.get(parentKey);\n        if (!parentNode) {\n          return;\n        }\n\n        this.insert(parentKey, parentNode.children.length, ...values);\n      }\n    },\n    remove(...keys: Key[]) {\n      let newItems = items;\n      for (let key of keys) {\n        newItems = updateTree(newItems, key, () => null);\n      }\n\n      setItems(newItems);\n\n      let selection = new Set(selectedKeys);\n      for (let key of selectedKeys) {\n        if (!map.has(key)) {\n          selection.delete(key);\n        }\n      }\n\n      setSelectedKeys(selection);\n    },\n    removeSelectedItems() {\n      this.remove(...selectedKeys);\n    },\n    move(key: Key, toParentKey: Key, index: number) {\n      setItems(items => {\n        let node = map.get(key);\n        if (!node) {\n          return items;\n        }\n\n        items = updateTree(items, key, () => null);\n\n        const movedNode = {\n          ...node,\n          parentKey: toParentKey\n        };\n\n        return updateTree(items, toParentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [\n            ...parentNode.children.slice(0, index),\n            movedNode,\n            ...parentNode.children.slice(index)\n          ]\n        }));\n      });\n    },\n    update(oldKey: Key, newValue: T) {\n      setItems(items => updateTree(items, oldKey, oldNode => {\n        let node: TreeNode<T> = {\n          key: oldNode.key,\n          parentKey: oldNode.parentKey,\n          value: newValue,\n          children: null\n        };\n\n        node.children = buildTree(getChildren(newValue), node.key);\n        return node;\n      }));\n    }\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useNumberFieldState} from './useNumberFieldState';\n\nexport type {NumberFieldStateOptions} from './useNumberFieldState';\nexport type {NumberFieldState} from './useNumberFieldState';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {clamp, snapValueToStep, useControlledState} from '@react-stately/utils';\nimport {NumberFieldProps} from '@react-types/numberfield';\nimport {NumberFormatter, NumberParser} from '@internationalized/number';\nimport {useCallback, useMemo, useRef, useState} from 'react';\n\nexport interface NumberFieldState {\n  /**\n   * The current text value of the input. Updated as the user types,\n   * and formatted according to `formatOptions` on blur.\n   */\n  inputValue: string,\n  /**\n   * The currently parsed number value, or NaN if a valid number could not be parsed.\n   * Updated based on the `inputValue` as the user types.\n   */\n  numberValue: number,\n  /** The minimum value of the number field. */\n  minValue: number,\n  /** The maximum value of the number field. */\n  maxValue: number,\n  /** Whether the current value can be incremented according to the maximum value and step. */\n  canIncrement: boolean,\n  /** Whether the current value can be decremented according to the minimum value and step. */\n  canDecrement: boolean,\n  /**\n   * Validates a user input string according to the current locale and format options.\n   * Values can be partially entered, and may be valid even if they cannot currently be parsed to a number.\n   * Can be used to implement validation as a user types.\n   */\n  validate(value: string): boolean,\n  /** Sets the current text value of the input. */\n  setInputValue(val: string): void,\n  /**\n   * Commits the current input value. The value is parsed to a number, clamped according\n   * to the minimum and maximum values of the field, and snapped to the nearest step value.\n   * This will fire the `onChange` prop with the new value, and if uncontrolled, update the `numberValue`.\n   * Typically this is called when the field is blurred.\n   */\n  commit(): void,\n  /** Increments the current input value to the next step boundary, and fires `onChange`. */\n  increment(): void,\n  /** Decrements the current input value to the next step boundary, and fires `onChange`. */\n  decrement(): void,\n  /** Sets the current value to the `maxValue` if any, and fires `onChange`. */\n  incrementToMax(): void,\n  /** Sets the current value to the `minValue` if any, and fires `onChange`. */\n  decrementToMin(): void\n}\n\nexport interface NumberFieldStateOptions extends NumberFieldProps {\n  /**\n   * The locale that should be used for parsing.\n   * @default 'en-US'\n   */\n  locale: string\n}\n\n/**\n * Provides state management for a number field component. Number fields allow users to enter a number,\n * and increment or decrement the value using stepper buttons.\n */\nexport function useNumberFieldState(\n  props: NumberFieldStateOptions\n): NumberFieldState {\n  let {\n    minValue,\n    maxValue,\n    step,\n    formatOptions,\n    value,\n    defaultValue,\n    onChange,\n    locale,\n    isDisabled,\n    isReadOnly\n  } = props;\n\n  let [numberValue, setNumberValue] = useControlledState<number>(value, isNaN(defaultValue) ? NaN : defaultValue, onChange);\n  let [inputValue, setInputValue] = useState(() => isNaN(numberValue) ? '' : new NumberFormatter(locale, formatOptions).format(numberValue));\n\n  let numberParser = useMemo(() => new NumberParser(locale, formatOptions), [locale, formatOptions]);\n  let numberingSystem = useMemo(() => numberParser.getNumberingSystem(inputValue), [numberParser, inputValue]);\n  let formatter = useMemo(() => new NumberFormatter(locale, {...formatOptions, numberingSystem}), [locale, formatOptions, numberingSystem]);\n  let intlOptions = useMemo(() => formatter.resolvedOptions(), [formatter]);\n  let format = useCallback((value: number) => isNaN(value) ? '' : formatter.format(value), [formatter]);\n\n  let clampStep = !isNaN(step) ? step : 1;\n  if (intlOptions.style === 'percent' && isNaN(step)) {\n    clampStep = 0.01;\n  }\n\n  // Update the input value when the number value or format options change. This is done\n  // in a useEffect so that the controlled behavior is correct and we only update the\n  // textfield after prop changes.\n  let prevValue = useRef(numberValue);\n  let prevLocale = useRef(locale);\n  let prevFormatOptions = useRef(formatOptions);\n  if (!Object.is(numberValue, prevValue.current) || locale !== prevLocale.current || formatOptions !== prevFormatOptions.current) {\n    setInputValue(format(numberValue));\n    prevValue.current = numberValue;\n    prevLocale.current = locale;\n    prevFormatOptions.current = formatOptions;\n  }\n\n  // Store last parsed value in a ref so it can be used by increment/decrement below\n  let parsedValue = useMemo(() => numberParser.parse(inputValue), [numberParser, inputValue]);\n  let parsed = useRef(0);\n  parsed.current = parsedValue;\n\n  let commit = () => {\n    // Set to empty state if input value is empty\n    if (!inputValue.length) {\n      setNumberValue(NaN);\n      setInputValue(value === undefined ? '' : format(numberValue));\n      return;\n    }\n\n    // if it failed to parse, then reset input to formatted version of current number\n    if (isNaN(parsed.current)) {\n      setInputValue(format(numberValue));\n      return;\n    }\n\n    // Clamp to min and max, round to the nearest step, and round to specified number of digits\n    let clampedValue: number;\n    if (isNaN(step)) {\n      clampedValue = clamp(parsed.current, minValue, maxValue);\n    } else {\n      clampedValue = snapValueToStep(parsed.current, minValue, maxValue, step);\n    }\n\n    clampedValue = numberParser.parse(format(clampedValue));\n    setNumberValue(clampedValue);\n\n    // in a controlled state, the numberValue won't change, so we won't go back to our old input without help\n    setInputValue(format(value === undefined ? clampedValue : numberValue));\n  };\n\n  let safeNextStep = (operation: '+' | '-', minMax: number) => {\n    let prev = parsed.current;\n\n    if (isNaN(prev)) {\n      // if the input is empty, start from the min/max value when incrementing/decrementing,\n      // or zero if there is no min/max value defined.\n      let newValue = isNaN(minMax) ? 0 : minMax;\n      return snapValueToStep(newValue, minValue, maxValue, clampStep);\n    } else {\n      // otherwise, first snap the current value to the nearest step. if it moves in the direction\n      // we're going, use that value, otherwise add the step and snap that value.\n      let newValue = snapValueToStep(prev, minValue, maxValue, clampStep);\n      if ((operation === '+' && newValue > prev) || (operation === '-' && newValue < prev)) {\n        return newValue;\n      }\n\n      return snapValueToStep(\n        handleDecimalOperation(operation, prev, clampStep),\n        minValue,\n        maxValue,\n        clampStep\n      );\n    }\n  };\n\n  let increment = () => {\n    let newValue = safeNextStep('+', minValue);\n\n    // if we've arrived at the same value that was previously in the state, the\n    // input value should be updated to match\n    // ex type 4, press increment, highlight the number in the input, type 4 again, press increment\n    // you'd be at 5, then incrementing to 5 again, so no re-render would happen and 4 would be left in the input\n    if (newValue === numberValue) {\n      setInputValue(format(newValue));\n    }\n\n    setNumberValue(newValue);\n  };\n\n  let decrement = () => {\n    let newValue = safeNextStep('-', maxValue);\n\n    if (newValue === numberValue) {\n      setInputValue(format(newValue));\n    }\n\n    setNumberValue(newValue);\n  };\n\n  let incrementToMax = () => {\n    if (maxValue != null) {\n      setNumberValue(snapValueToStep(maxValue, minValue, maxValue, clampStep));\n    }\n  };\n\n  let decrementToMin = () => {\n    if (minValue != null) {\n      setNumberValue(minValue);\n    }\n  };\n\n  let canIncrement = useMemo(() => (\n    !isDisabled &&\n    !isReadOnly &&\n    (\n      isNaN(parsedValue) ||\n      isNaN(maxValue) ||\n      snapValueToStep(parsedValue, minValue, maxValue, clampStep) > parsedValue ||\n      handleDecimalOperation('+', parsedValue, clampStep) <= maxValue\n    )\n  ), [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n\n  let canDecrement = useMemo(() => (\n    !isDisabled &&\n    !isReadOnly &&\n    (\n      isNaN(parsedValue) ||\n      isNaN(minValue) ||\n      snapValueToStep(parsedValue, minValue, maxValue, clampStep) < parsedValue ||\n      handleDecimalOperation('-', parsedValue, clampStep) >= minValue\n    )\n  ), [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n\n  let validate = (value: string) => numberParser.isValidPartialNumber(value, minValue, maxValue);\n\n  return {\n    validate,\n    increment,\n    incrementToMax,\n    decrement,\n    decrementToMin,\n    canIncrement,\n    canDecrement,\n    minValue,\n    maxValue,\n    numberValue: parsedValue,\n    setInputValue,\n    inputValue,\n    commit\n  };\n}\n\nfunction handleDecimalOperation(operator: '-' | '+', value1: number, value2: number): number {\n  let result = operator === '+' ? value1 + value2 : value1 - value2;\n\n  // Check if we have decimals\n  if (value1 % 1 !== 0 || value2 % 1 !== 0) {\n    const value1Decimal = value1.toString().split('.');\n    const value2Decimal = value2.toString().split('.');\n    const value1DecimalLength = (value1Decimal[1] && value1Decimal[1].length) || 0;\n    const value2DecimalLength = (value2Decimal[1] && value2Decimal[1].length) || 0;\n    const multiplier = Math.pow(10, Math.max(value1DecimalLength, value2DecimalLength));\n\n    // Transform the decimals to integers based on the precision\n    value1 = Math.round(value1 * multiplier);\n    value2 = Math.round(value2 * multiplier);\n\n    // Perform the operation on integers values to make sure we don't get a fancy decimal value\n    result = operator === '+' ? value1 + value2 : value1 - value2;\n\n    // Transform the integer result back to decimal\n    result /= multiplier;\n  }\n\n  return result;\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useRadioGroupState} from './useRadioGroupState';\n\nexport type {RadioGroupProps} from '@react-types/radio';\nexport type {RadioGroupState} from './useRadioGroupState';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {RadioGroupProps} from '@react-types/radio';\nimport {useControlledState} from '@react-stately/utils';\nimport {useMemo, useState} from 'react';\nimport {ValidationState} from '@react-types/shared';\n\nexport interface RadioGroupState {\n  /**\n   * The name for the group, used for native form submission.\n   * @deprecated\n   * @private\n   */\n  readonly name: string,\n\n  /** Whether the radio group is disabled. */\n  readonly isDisabled: boolean,\n\n  /** Whether the radio group is read only. */\n  readonly isReadOnly: boolean,\n\n  /** The currently selected value. */\n  readonly selectedValue: string | null,\n\n  /** Sets the selected value. */\n  setSelectedValue(value: string): void,\n\n  /** The value of the last focused radio. */\n  readonly lastFocusedValue: string | null,\n\n  /** Sets the last focused value. */\n  setLastFocusedValue(value: string): void,\n\n  /** The current validation state of the radio group. */\n  validationState: ValidationState\n}\n\nlet instance = Math.round(Math.random() * 10000000000);\nlet i = 0;\n\n/**\n * Provides state management for a radio group component. Provides a name for the group,\n * and manages selection and focus state.\n */\nexport function useRadioGroupState(props: RadioGroupProps): RadioGroupState  {\n  // Preserved here for backward compatibility. React Aria now generates the name instead of stately.\n  let name = useMemo(() => props.name || `radio-group-${instance}-${++i}`, [props.name]);\n  let [selectedValue, setSelected] = useControlledState(props.value, props.defaultValue, props.onChange);\n  let [lastFocusedValue, setLastFocusedValue] = useState(null);\n\n  let setSelectedValue = (value) => {\n    if (!props.isReadOnly && !props.isDisabled) {\n      setSelected(value);\n    }\n  };\n\n  return {\n    name,\n    selectedValue,\n    setSelectedValue,\n    lastFocusedValue,\n    setLastFocusedValue,\n    isDisabled: props.isDisabled || false,\n    isReadOnly: props.isReadOnly || false,\n    validationState: props.validationState\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useSearchFieldState} from './useSearchFieldState';\n\nexport type {SearchFieldProps} from '@react-types/searchfield';\nexport type {SearchFieldState} from './useSearchFieldState';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {SearchFieldProps} from '@react-types/searchfield';\nimport {useControlledState} from '@react-stately/utils';\n\nexport interface SearchFieldState {\n  /** The current value of the search field. */\n  readonly value: string,\n\n  /** Sets the value of the search field. */\n  setValue(value: string): void\n}\n\n/**\n * Provides state management for a search field.\n */\nexport function useSearchFieldState(props: SearchFieldProps): SearchFieldState {\n  let [value, setValue] = useControlledState(toString(props.value), toString(props.defaultValue) || '', props.onChange);\n\n  return {\n    value,\n    setValue\n  };\n}\n\nfunction toString(val) {\n  if (val == null) {\n    return;\n  }\n\n  return val.toString();\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useSelectState} from './useSelectState';\n\nexport type {SelectProps} from '@react-types/select';\nexport type {SelectState} from './useSelectState';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {MenuTriggerState, useMenuTriggerState} from '@react-stately/menu';\nimport {SelectProps} from '@react-types/select';\nimport {SingleSelectListState, useSingleSelectListState} from '@react-stately/list';\nimport {useState} from 'react';\n\nexport interface SelectState<T> extends SingleSelectListState<T>, MenuTriggerState {\n  /** Whether the select is currently focused. */\n  readonly isFocused: boolean,\n\n  /** Sets whether the select is focused. */\n  setFocused(isFocused: boolean): void\n}\n\n/**\n * Provides state management for a select component. Handles building a collection\n * of items from props, handles the open state for the popup menu, and manages\n * multiple selection state.\n */\nexport function useSelectState<T extends object>(props: SelectProps<T>): SelectState<T>  {\n  let triggerState = useMenuTriggerState(props);\n  let listState = useSingleSelectListState({\n    ...props,\n    onSelectionChange: (key) => {\n      if (props.onSelectionChange != null) {\n        props.onSelectionChange(key);\n      }\n\n      triggerState.close();\n    }\n  });\n\n  let [isFocused, setFocused] = useState(false);\n\n  return {\n    ...listState,\n    ...triggerState,\n    open() {\n      // Don't open if the collection is empty.\n      if (listState.collection.size !== 0) {\n        triggerState.open();\n      }\n    },\n    toggle(focusStrategy) {\n      if (listState.collection.size !== 0) {\n        triggerState.toggle(focusStrategy);\n      }\n    },\n    isFocused,\n    setFocused\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useSliderState} from './useSliderState';\n\nexport type {SliderStateOptions} from './useSliderState';\nexport type {SliderState} from './useSliderState';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {clamp, snapValueToStep} from '@react-aria/utils';\nimport {Orientation} from '@react-types/shared';\nimport {SliderProps} from '@react-types/slider';\nimport {useControlledState} from '@react-stately/utils';\nimport {useMemo, useRef, useState} from 'react';\n\nexport interface SliderState {\n  /**\n   * Values managed by the slider by thumb index.\n   */\n  readonly values: number[],\n  /**\n   * Get the value for the specified thumb.\n   * @param index\n   */\n  getThumbValue(index: number): number,\n\n  /**\n   * Sets the value for the specified thumb.\n   * The actual value set will be clamped and rounded according to min/max/step.\n   * @param index\n   * @param value\n   */\n  setThumbValue(index: number, value: number): void,\n\n  /**\n   * Sets value for the specified thumb by percent offset (between 0 and 1).\n   * @param index\n   * @param percent\n   */\n  setThumbPercent(index: number, percent: number): void,\n\n  /**\n   * Whether the specific thumb is being dragged.\n   * @param index\n   */\n  isThumbDragging(index: number): boolean,\n  /**\n   * Set is dragging on the specified thumb.\n   * @param index\n   * @param dragging\n   */\n  setThumbDragging(index: number, dragging: boolean): void,\n\n  /**\n   * Currently-focused thumb index.\n   */\n  readonly focusedThumb: number | undefined,\n  /**\n   * Set focused true on specified thumb. This will remove focus from\n   * any thumb that had it before.\n   * @param index\n   */\n  setFocusedThumb(index: number | undefined): void,\n\n  /**\n   * Returns the specified thumb's value as a percentage from 0 to 1.\n   * @param index\n   */\n  getThumbPercent(index: number): number,\n\n  /**\n   * Returns the value as a percent between the min and max of the slider.\n   * @param index\n   */\n  getValuePercent(value: number): number,\n\n  /**\n   * Returns the string label for the specified thumb's value, per props.formatOptions.\n   * @param index\n   */\n  getThumbValueLabel(index: number): string,\n\n  /**\n   * Returns the string label for the value, per props.formatOptions.\n   * @param index\n   */\n  getFormattedValue(value: number): string,\n\n  /**\n   * Returns the min allowed value for the specified thumb.\n   * @param index\n   */\n  getThumbMinValue(index: number): number,\n\n  /**\n   * Returns the max allowed value for the specified thumb.\n   * @param index\n   */\n  getThumbMaxValue(index: number): number,\n\n  /**\n   * Converts a percent along track (between 0 and 1) to the corresponding value.\n   * @param percent\n   */\n  getPercentValue(percent: number): number,\n\n  /**\n   * Returns if the specified thumb is editable.\n   * @param index\n   */\n  isThumbEditable(index: number): boolean,\n\n  /**\n   * Set the specified thumb's editable state.\n   * @param index\n   * @param editable\n   */\n  setThumbEditable(index: number, editable: boolean): void,\n\n  /**\n   * Increments the value of the thumb by the step or page amount.\n   */\n  incrementThumb(index: number, stepSize?: number): void,\n  /**\n   * Decrements the value of the thumb by the step or page amount.\n   */\n  decrementThumb(index: number, stepSize?: number): void,\n\n  /**\n   * The step amount for the slider.\n   */\n  readonly step: number,\n\n  /**\n   * The page size for the slider, used to do a bigger step.\n   */\n  readonly pageSize: number,\n\n  /** The orientation of the slider. */\n  readonly orientation: Orientation,\n\n  /** Whether the slider is disabled. */\n  readonly isDisabled: boolean\n}\n\nconst DEFAULT_MIN_VALUE = 0;\nconst DEFAULT_MAX_VALUE = 100;\nconst DEFAULT_STEP_VALUE = 1;\n\nexport interface SliderStateOptions<T> extends SliderProps<T> {\n  numberFormatter: Intl.NumberFormat\n}\n\n/**\n * Provides state management for a slider component. Stores values for all thumbs,\n * formats values for localization, and provides methods to update the position\n * of any thumbs.\n * @param props\n */\nexport function useSliderState<T extends number | number[]>(props: SliderStateOptions<T>): SliderState {\n  const {\n    isDisabled = false,\n    minValue = DEFAULT_MIN_VALUE,\n    maxValue = DEFAULT_MAX_VALUE,\n    numberFormatter: formatter,\n    step = DEFAULT_STEP_VALUE,\n    orientation = 'horizontal'\n  } = props;\n\n  // Page step should be at least equal to step and always a multiple of the step.\n  let pageSize = useMemo(() => {\n    let calcPageSize = (maxValue - minValue) / 10;\n    calcPageSize = snapValueToStep(calcPageSize, 0, calcPageSize + step, step);\n    return Math.max(calcPageSize, step);\n  }, [step, maxValue, minValue]);\n\n  let value = useMemo(() => convertValue(props.value), [props.value]);\n  let defaultValue = useMemo(() => convertValue(props.defaultValue) ?? [minValue], [props.defaultValue, minValue]);\n  let onChange = createOnChange(props.value, props.defaultValue, props.onChange);\n  let onChangeEnd = createOnChange(props.value, props.defaultValue, props.onChangeEnd);\n\n  const [values, setValues] = useControlledState<number[]>(\n    value,\n    defaultValue,\n    onChange\n  );\n  const [isDraggings, setDraggings] = useState<boolean[]>(new Array(values.length).fill(false));\n  const isEditablesRef = useRef<boolean[]>(new Array(values.length).fill(true));\n  const [focusedIndex, setFocusedIndex] = useState<number | undefined>(undefined);\n\n  const valuesRef = useRef<number[]>(null);\n  valuesRef.current = values;\n  const isDraggingsRef = useRef<boolean[]>(null);\n  isDraggingsRef.current = isDraggings;\n\n  function getValuePercent(value: number) {\n    return (value - minValue) / (maxValue - minValue);\n  }\n\n  function getThumbMinValue(index: number) {\n    return index === 0 ? minValue : values[index - 1];\n  }\n  function getThumbMaxValue(index: number) {\n    return index === values.length - 1 ? maxValue : values[index + 1];\n  }\n\n  function isThumbEditable(index: number) {\n    return isEditablesRef.current[index];\n  }\n\n  function setThumbEditable(index: number, editable: boolean) {\n    isEditablesRef.current[index] = editable;\n  }\n\n  function updateValue(index: number, value: number) {\n    if (isDisabled || !isThumbEditable(index)) {\n      return;\n    }\n    const thisMin = getThumbMinValue(index);\n    const thisMax = getThumbMaxValue(index);\n\n    // Round value to multiple of step, clamp value between min and max\n    value = snapValueToStep(value, thisMin, thisMax, step);\n    valuesRef.current = replaceIndex(valuesRef.current, index, value);\n    setValues(valuesRef.current);\n  }\n\n  function updateDragging(index: number, dragging: boolean) {\n    if (isDisabled || !isThumbEditable(index)) {\n      return;\n    }\n\n    const wasDragging = isDraggingsRef.current[index];\n    isDraggingsRef.current = replaceIndex(isDraggingsRef.current, index, dragging);\n    setDraggings(isDraggingsRef.current);\n\n    // Call onChangeEnd if no handles are dragging.\n    if (onChangeEnd && wasDragging && !isDraggingsRef.current.some(Boolean)) {\n      onChangeEnd(valuesRef.current);\n    }\n  }\n\n  function getFormattedValue(value: number) {\n    return formatter.format(value);\n  }\n\n  function setThumbPercent(index: number, percent: number) {\n    updateValue(index, getPercentValue(percent));\n  }\n\n  function getRoundedValue(value: number) {\n    return Math.round((value - minValue) / step) * step + minValue;\n  }\n\n  function getPercentValue(percent: number) {\n    const val = percent * (maxValue - minValue) + minValue;\n    return clamp(getRoundedValue(val), minValue, maxValue);\n  }\n\n  function incrementThumb(index: number, stepSize: number = 1) {\n    let s = Math.max(stepSize, step);\n    updateValue(index, snapValueToStep(values[index] + s, minValue, maxValue, step));\n  }\n\n  function decrementThumb(index: number, stepSize: number = 1) {\n    let s = Math.max(stepSize, step);\n    updateValue(index, snapValueToStep(values[index] - s, minValue, maxValue, step));\n  }\n\n  return {\n    values: values,\n    getThumbValue: (index: number) => values[index],\n    setThumbValue: updateValue,\n    setThumbPercent,\n    isThumbDragging: (index: number) => isDraggings[index],\n    setThumbDragging: updateDragging,\n    focusedThumb: focusedIndex,\n    setFocusedThumb: setFocusedIndex,\n    getThumbPercent: (index: number) => getValuePercent(values[index]),\n    getValuePercent,\n    getThumbValueLabel: (index: number) => getFormattedValue(values[index]),\n    getFormattedValue,\n    getThumbMinValue,\n    getThumbMaxValue,\n    getPercentValue,\n    isThumbEditable,\n    setThumbEditable,\n    incrementThumb,\n    decrementThumb,\n    step,\n    pageSize,\n    orientation,\n    isDisabled\n  };\n}\n\nfunction replaceIndex<T>(array: T[], index: number, value: T) {\n  if (array[index] === value) {\n    return array;\n  }\n\n  return [...array.slice(0, index), value, ...array.slice(index + 1)];\n}\n\nfunction convertValue(value: number | number[]) {\n  if (value == null) {\n    return undefined;\n  }\n\n  return Array.isArray(value) ? value : [value];\n}\n\nfunction createOnChange(value, defaultValue, onChange) {\n  return (newValue: number[]) => {\n    if (typeof value === 'number' || typeof defaultValue === 'number') {\n      onChange?.(newValue[0]);\n    } else {\n      onChange?.(newValue);\n    }\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useGridState} from './useGridState';\nexport {GridCollection} from './GridCollection';\n\nexport type {GridStateOptions, GridState} from './useGridState';\n", "import {GridCollection} from '@react-types/grid';\nimport {Key, useEffect, useMemo} from 'react';\nimport {MultipleSelectionStateProps, SelectionManager, useMultipleSelectionState} from '@react-stately/selection';\n\nexport interface GridState<T, C extends GridCollection<T>> {\n  collection: C,\n  /** A set of keys for rows that are disabled. */\n  disabledKeys: Set<Key>,\n  /** A selection manager to read and update row selection state. */\n  selectionManager: SelectionManager,\n  /** Whether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell. */\n  isKeyboardNavigationDisabled: boolean\n}\n\nexport interface GridStateOptions<T, C extends GridCollection<T>> extends MultipleSelectionStateProps {\n  collection: C,\n  disabledKeys?: Iterable<Key>,\n  focusMode?: 'row' | 'cell'\n}\n\n/**\n * Provides state management for a grid component. Handles row selection and focusing a grid cell's focusable child if applicable.\n */\nexport function useGridState<T extends object, C extends GridCollection<T>>(props: GridStateOptions<T, C>): GridState<T, C> {\n  let {collection, focusMode} = props;\n  let selectionState = useMultipleSelectionState(props);\n  let disabledKeys = useMemo(() =>\n      props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()\n    , [props.disabledKeys]);\n\n  let setFocusedKey = selectionState.setFocusedKey;\n  selectionState.setFocusedKey = (key, child) => {\n    // If focusMode is cell and an item is focused, focus a child cell instead.\n    if (focusMode === 'cell' && key != null) {\n      let item = collection.getItem(key);\n      if (item?.type === 'item') {\n        let children = [...item.childNodes];\n        if (child === 'last') {\n          key = children[children.length - 1]?.key;\n        } else {\n          key = children[0]?.key;\n        }\n      }\n    }\n\n    setFocusedKey(key, child);\n  };\n\n  // Reset focused key if that item is deleted from the collection.\n  useEffect(() => {\n    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n      selectionState.setFocusedKey(null);\n    }\n  }, [collection, selectionState]);\n\n  return {\n    collection,\n    disabledKeys,\n    isKeyboardNavigationDisabled: false,\n    selectionManager: new SelectionManager(collection, selectionState)\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {GridNode, GridRow, GridCollection as IGridCollection} from '@react-types/grid';\nimport {Key} from 'react';\n\n\ninterface GridCollectionOptions<T> {\n  columnCount: number,\n  items: GridRow<T>[],\n  visitNode?: (cell: GridNode<T>) => GridNode<T>\n}\n\nexport class GridCollection<T> implements IGridCollection<T> {\n  keyMap: Map<Key, GridNode<T>> = new Map();\n  columnCount: number;\n  rows: GridNode<T>[];\n\n  constructor(opts?: GridCollectionOptions<T>) {\n    this.keyMap = new Map();\n    this.columnCount = opts?.columnCount;\n    this.rows = [];\n\n    let visit = (node: GridNode<T>) => {\n      // If the node is the same object as the previous node for the same key,\n      // we can skip this node and its children. We always visit columns though,\n      // because we depend on order to build the columns array.\n      let prevNode = this.keyMap.get(node.key);\n      if (opts.visitNode) {\n        node = opts.visitNode(node);\n      }\n\n      this.keyMap.set(node.key, node);\n\n      let childKeys = new Set();\n      let last: GridNode<T>;\n      for (let child of node.childNodes) {\n        if (child.type === 'cell' && child.parentKey == null) {\n          // if child is a cell parent key isn't already established by the collection, match child node to parent row\n          child.parentKey = node.key;\n        }\n        childKeys.add(child.key);\n\n        if (last) {\n          last.nextKey = child.key;\n          child.prevKey = last.key;\n        } else {\n          child.prevKey = null;\n        }\n\n        visit(child);\n        last = child;\n      }\n\n      if (last) {\n        last.nextKey = null;\n      }\n\n      // Remove deleted nodes and their children from the key map\n      if (prevNode) {\n        for (let child of prevNode.childNodes) {\n          if (!childKeys.has(child.key)) {\n            remove(child);\n          }\n        }\n      }\n    };\n\n    let remove = (node: GridNode<T>) => {\n      this.keyMap.delete(node.key);\n      for (let child of node.childNodes) {\n        if (this.keyMap.get(child.key) === child) {\n          remove(child);\n        }\n      }\n    };\n\n    let last: GridNode<T>;\n    opts.items.forEach((node, i) => {\n      let rowNode = {\n        level: 0,\n        key: 'row-' + i,\n        type: 'row',\n        value: undefined,\n        hasChildNodes: true,\n        childNodes: [...node.childNodes],\n        rendered: undefined,\n        textValue: undefined,\n        ...node,\n        index: i\n      } as GridNode<T>;\n\n      if (last) {\n        last.nextKey = rowNode.key;\n        rowNode.prevKey = last.key;\n      } else {\n        rowNode.prevKey = null;\n      }\n\n      this.rows.push(rowNode);\n      visit(rowNode);\n\n      last = rowNode;\n    });\n\n    if (last) {\n      last.nextKey = null;\n    }\n  }\n\n  *[Symbol.iterator]() {\n    yield* [...this.rows];\n  }\n\n  get size() {\n    return [...this.rows].length;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    return [...this.rows][0]?.key;\n  }\n\n  getLastKey() {\n    let rows = [...this.rows];\n    return rows[rows.length - 1]?.key;\n  }\n\n  getItem(key: Key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx: number) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport type {TableColumnResizeState, TableColumnResizeStateProps} from './useTableColumnResizeState';\nexport type {TableState, CollectionBuilderContext, TableStateProps} from './useTableState';\nexport type {TableHeaderProps, TableBodyProps, ColumnProps, RowProps, CellProps} from '@react-types/table';\n\nexport {useTableColumnResizeState} from './useTableColumnResizeState';\nexport {useTableState} from './useTableState';\nexport {TableHeader} from './TableHeader';\nexport {TableBody} from './TableBody';\nexport {Column} from './Column';\nexport {Row} from './Row';\nexport {Cell} from './Cell';\nexport {Section} from '@react-stately/collections';\n", "\nimport {ColumnProps} from '@react-types/table';\nimport {getContentWidth, getDynamicColumnWidths, getMaxWidth, getMinWidth, isStatic, parseStaticWidth} from './utils';\nimport {GridNode} from '@react-types/grid';\nimport {Key, MutableRefObject, useCallback, useRef, useState} from 'react';\n\ninterface AffectedColumnWidth {\n  /** The column key. */\n  key: Key,\n  /** The column width. */\n  width: number\n}\ninterface AffectedColumnWidths extends Array<AffectedColumnWidth> {}\n\nexport interface TableColumnResizeState<T> {\n  /** A ref whose current value is the state of all the column widths. */\n  columnWidths: MutableRefObject<Map<Key, number>>,\n  /** Setter for the table width. */\n  setTableWidth: (width: number) => void,\n  /** Trigger a resize and recalculation. */\n  onColumnResize: (column: GridNode<T>, width: number) => void,\n  /** Callback for when onColumnResize has started. */\n  onColumnResizeStart: (column: GridNode<T>) => void,\n  /** Callback for when onColumnResize has ended. */\n  onColumnResizeEnd: (column: GridNode<T>) => void,\n  /** Getter for column width. */\n  getColumnWidth: (key: Key) => number,\n  /** Getter for column min width. */\n  getColumnMinWidth: (key: Key) => number,\n  /** Getter for column max widths. */\n  getColumnMaxWidth: (key: Key) => number,\n  /** Key of column currently being resized. */\n  currentlyResizingColumn: Key | null\n}\n\nexport interface TableColumnResizeStateProps {\n  /** Callback to determine what the default width of a column should be. */\n  getDefaultWidth?: (props) => string | number,\n  /** Callback that is invoked during the entirety of the resize event. */\n  onColumnResize?: (affectedColumnWidths: AffectedColumnWidths) => void,\n  /** Callback that is invoked when the resize event is ended. */\n  onColumnResizeEnd?: (affectedColumnWidths: AffectedColumnWidths) => void,\n  /** The default table width. */\n  tableWidth?: number\n}\n\ninterface ColumnState<T> {\n  columns: GridNode<T>[]\n}\n\nexport function useTableColumnResizeState<T>(props: TableColumnResizeStateProps, state: ColumnState<T>): TableColumnResizeState<T> {\n  const {getDefaultWidth, tableWidth: defaultTableWidth = null} = props;\n  const {columns} = state;\n  const columnsRef = useRef<GridNode<T>[]>([]);\n  const tableWidth = useRef<number>(defaultTableWidth);\n  const isResizing = useRef<boolean>(null);\n  const startResizeContentWidth = useRef<number>();\n\n  const [columnWidths, setColumnWidths] = useState<Map<Key, number>>(new Map(columns.map(col => [col.key, 0])));\n  const columnWidthsRef = useRef<Map<Key, number>>(columnWidths);\n  const affectedColumnWidthsRef = useRef<AffectedColumnWidths>([]);\n  const [resizedColumns, setResizedColumns] = useState<Set<Key>>(new Set());\n  const resizedColumnsRef = useRef<Set<Key>>(resizedColumns);\n\n  const [currentlyResizingColumn, setCurrentlyResizingColumn] = useState<Key>(null);\n\n  function setColumnWidthsForRef(newWidths: Map<Key, number>) {\n    columnWidthsRef.current = newWidths;\n    // new map so that change detection is triggered\n    setColumnWidths(newWidths);\n  }\n  /*\n    returns the resolved column width in this order:\n    previously calculated width -> controlled width prop -> uncontrolled defaultWidth prop -> dev assigned width -> default dynamic width\n  */\n  let getResolvedColumnWidth = useCallback((column: GridNode<T>): (number | string) => {\n    let columnProps = column.props as ColumnProps<T>;\n    return resizedColumns?.has(column.key) ? columnWidthsRef.current.get(column.key) : columnProps.width ?? columnProps.defaultWidth ?? getDefaultWidth?.(column.props) ?? '1fr';\n  }, [getDefaultWidth, resizedColumns]);\n\n  let getStaticAndDynamicColumns = useCallback((columns: GridNode<T>[]) : { staticColumns: GridNode<T>[], dynamicColumns: GridNode<T>[] } => columns.reduce((acc, column) => {\n    let width = getResolvedColumnWidth(column);\n    return isStatic(width) ? {...acc, staticColumns: [...acc.staticColumns, column]} : {...acc, dynamicColumns: [...acc.dynamicColumns, column]};\n  }, {staticColumns: [], dynamicColumns: []}), [getResolvedColumnWidth]);\n\n  let buildColumnWidths = useCallback((affectedColumns: GridNode<T>[], availableSpace: number): Map<Key, number> => {\n    const widths = new Map<Key, number>();\n    let remainingSpace = availableSpace;\n\n    const {staticColumns, dynamicColumns} = getStaticAndDynamicColumns(affectedColumns);\n\n    staticColumns.forEach(column => {\n      let width = getResolvedColumnWidth(column);\n      let w = parseStaticWidth(width, tableWidth.current);\n      widths.set(column.key, w);\n      remainingSpace -= w;\n    });\n\n    // dynamic columns\n    if (dynamicColumns.length > 0) {\n      const newColumnWidths = getDynamicColumnWidths(dynamicColumns, remainingSpace, tableWidth.current);\n      for (let column of newColumnWidths) {\n        widths.set(column.key, column.calculatedWidth);\n      }\n    }\n\n    return widths;\n  }, [getStaticAndDynamicColumns, getResolvedColumnWidth]);\n\n\n  const prevColKeys = columnsRef.current.map(col => col.key);\n  const colKeys = columns.map(col => col.key);\n  // if the columns change, need to rebuild widths.\n  if (prevColKeys.length !== colKeys.length || !colKeys.every((col, i) => col === prevColKeys[i])) {\n    columnsRef.current = columns;\n    const widths = buildColumnWidths(columns, tableWidth.current);\n    setColumnWidthsForRef(widths);\n  }\n\n  function setTableWidth(width: number) {\n    if (width && width !== tableWidth.current) {\n      tableWidth.current = width;\n      if (!isResizing.current) {\n        const widths = buildColumnWidths(columns, width);\n        setColumnWidthsForRef(widths);\n      }\n    }\n  }\n\n  function onColumnResizeStart(column: GridNode<T>) {\n    setCurrentlyResizingColumn(column.key);\n    isResizing.current = true;\n    startResizeContentWidth.current = getContentWidth(columnWidthsRef.current);\n  }\n\n  function onColumnResize(column: GridNode<T>, width: number) {\n    let widthsObj = resizeColumn(column, width);\n    affectedColumnWidthsRef.current = widthsObj;\n    props.onColumnResize && props.onColumnResize(affectedColumnWidthsRef.current);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  function onColumnResizeEnd(column: GridNode<T>) {\n    props.onColumnResizeEnd && isResizing.current && props.onColumnResizeEnd(affectedColumnWidthsRef.current);\n    setCurrentlyResizingColumn(null);\n    isResizing.current = false;\n    affectedColumnWidthsRef.current = [];\n\n    let widths = new Map<Key, number>(columnWidthsRef.current);\n    setColumnWidthsForRef(widths);\n  }\n\n  function resizeColumn(column: GridNode<T>, newWidth: number) : AffectedColumnWidths {\n    let boundedWidth =  Math.max(\n      getMinWidth(column.props.minWidth, tableWidth.current),\n      Math.min(Math.floor(newWidth), getMaxWidth(column.props.maxWidth, tableWidth.current)));\n\n    // copy the columnWidths map and set the new width for the column being resized\n    let widths = new Map<Key, number>(columnWidthsRef.current);\n    widths.set(column.key, boundedWidth);\n\n    // keep track of all columns that have been sized\n    resizedColumnsRef.current.add(column.key);\n    setResizedColumns(resizedColumnsRef.current);\n\n    // get the columns affected by resize and remaining space\n    const resizeIndex = columnsRef.current.findIndex(col => col.key === column.key);\n    let affectedColumns = columnsRef.current.slice(resizeIndex + 1);\n\n    // we only care about the columns that CAN be resized, we ignore static columns.\n    let {dynamicColumns} = getStaticAndDynamicColumns(affectedColumns);\n\n    // available space for affected columns\n    let availableSpace = columnsRef.current.reduce((acc, column, index) => {\n      if (index <= resizeIndex || isStatic(getResolvedColumnWidth(column))) {\n        return acc - widths.get(column.key);\n      }\n      return acc;\n    }, tableWidth.current);\n\n    // merge the unaffected column widths and the recalculated column widths\n    let recalculatedColumnWidths = buildColumnWidths(dynamicColumns, availableSpace);\n    widths = new Map<Key, number>([...widths, ...recalculatedColumnWidths]);\n\n    setColumnWidthsForRef(widths);\n\n    /*\n     when getting recalculated columns above, the column being resized is not considered \"recalculated\"\n     so we need to add it to the list of affected columns\n    */\n    let allAffectedColumns = ([[column.key, boundedWidth], ...recalculatedColumnWidths] as [Key, number][]).map(([key, width]) => ({key, width}));\n    return allAffectedColumns;\n  }\n\n  // This function is regenerated whenever columnWidthsRef.current changes in order to get the new correct ref value.\n  let getColumnWidth = useCallback((key: Key): number => columnWidthsRef.current.get(key) ?? 0, [columnWidthsRef.current]);\n\n  let getColumnMinWidth = useCallback((key: Key) => {\n    const columnIndex = columns.findIndex(col => col.key === key);\n    if (columnIndex === -1) {\n      return;\n    }\n    return getMinWidth(columns[columnIndex].props.minWidth, tableWidth.current);\n  }, [columns]);\n\n  let getColumnMaxWidth = useCallback((key: Key) => {\n    const columnIndex = columns.findIndex(col => col.key === key);\n    if (columnIndex === -1) {\n      return;\n    }\n    return getMaxWidth(columns[columnIndex].props.maxWidth, tableWidth.current);\n  }, [columns]);\n\n  return {\n    columnWidths: columnWidthsRef,\n    setTableWidth,\n    onColumnResize,\n    onColumnResizeStart,\n    onColumnResizeEnd,\n    getColumnWidth,\n    getColumnMinWidth,\n    getColumnMaxWidth,\n    currentlyResizingColumn\n  };\n}\n", "import {GridNode} from '@react-types/grid';\nimport {Key} from 'react';\n\ntype mappedColumn<T> = GridNode<T> & {\n    index: number,\n    delta: number,\n    calculatedWidth?: number\n};\n\nexport function getContentWidth(widths: Map<Key, number>): number {\n  return Array.from(widths).map(e => e[1]).reduce((acc, cur) => acc + cur, 0);\n}\n\n// numbers and percents are considered static. *fr units or a lack of units are considered dynamic.\nexport function isStatic(width: number | string): boolean {\n  return width != null && (!isNaN(width as number) || (String(width)).match(/^(\\d+)(?=%$)/) !== null);\n}\n\nfunction parseFractionalUnit(width: string): number {\n  if (!width) {\n    return 1;\n  }\n  let match = width.match(/^(\\d+)(?=fr$)/);\n      // if width is the incorrect format, just deafult it to a 1fr\n  if (!match) {\n    console.warn(`width: ${width} is not a supported format, width should be a number (ex. 150), percentage (ex. '50%') or fr unit (ex. '2fr')`,\n        'defaulting to \\'1fr\\'');\n    return 1;\n  }\n  return parseInt(match[0], 10);\n}\n\nexport function parseStaticWidth(width: number | string, tableWidth: number): number {\n  if (typeof width === 'string') {\n    let match = width.match(/^(\\d+)(?=%$)/);\n    if (!match) {\n      throw new Error('Only percentages or numbers are supported for static column widths');\n    }\n    return tableWidth * (parseInt(match[0], 10) / 100);\n  }\n  return width;\n}\n\n\nexport function getMaxWidth(maxWidth: number | string, tableWidth: number): number {\n  return maxWidth != null\n        ? parseStaticWidth(maxWidth, tableWidth)\n        : Number.MAX_SAFE_INTEGER;\n}\n\nexport function getMinWidth(minWidth: number | string, tableWidth: number): number {\n  return minWidth != null\n      ? parseStaticWidth(minWidth, tableWidth)\n      : 75;\n}\n\nfunction mapDynamicColumns<T>(dynamicColumns: GridNode<T>[], availableSpace: number, tableWidth: number): mappedColumn<T>[] {\n  let fractions = dynamicColumns.reduce(\n        (sum, column) => sum + parseFractionalUnit(column.props.defaultWidth),\n        0\n      );\n\n  let columns = dynamicColumns.map((column, index) => {\n    const targetWidth =\n          (parseFractionalUnit(column.props.defaultWidth) * availableSpace) / fractions;\n    const delta = Math.max(\n      getMinWidth(column.props.minWidth, tableWidth) - targetWidth,\n      targetWidth - getMaxWidth(column.props.maxWidth, tableWidth)\n    );\n\n    return {\n      ...column,\n      index,\n      delta\n    };\n  });\n\n  return columns;\n}\n\nfunction findDynamicColumnWidths<T>(dynamicColumns: mappedColumn<T>[], availableSpace: number, tableWidth: number): mappedColumn<T>[] {\n  let fractions = dynamicColumns.reduce(\n    (sum, col) => sum + parseFractionalUnit(col.props.defaultWidth),\n    0\n  );\n\n  const columns = dynamicColumns.map((column) => {\n    const targetWidth =\n      (parseFractionalUnit(column.props.defaultWidth) * availableSpace) / fractions;\n    let width = Math.max(\n      getMinWidth(column.props.minWidth, tableWidth),\n      Math.min(Math.floor(targetWidth), getMaxWidth(column.props.maxWidth, tableWidth))\n    );\n    column.calculatedWidth = width;\n    availableSpace -= width;\n    fractions -= parseFractionalUnit(column.props.defaultWidth);\n    return column;\n  });\n\n  return columns;\n}\n\nexport function getDynamicColumnWidths<T>(dynamicColumns: GridNode<T>[], availableSpace: number, tableWidth: number) {\n  let columns = mapDynamicColumns(dynamicColumns, availableSpace, tableWidth);\n\n  columns.sort((a, b) => b.delta - a.delta);\n  columns = findDynamicColumnWidths(columns, availableSpace, tableWidth);\n  columns.sort((a, b) => a.index - b.index);\n\n  return columns;\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CollectionBase, Node, SelectionMode, Sortable, SortDescriptor, SortDirection} from '@react-types/shared';\nimport {GridState, useGridState} from '@react-stately/grid';\nimport {TableCollection as ITableCollection} from '@react-types/table';\nimport {Key, useMemo, useState} from 'react';\nimport {MultipleSelectionStateProps} from '@react-stately/selection';\nimport {TableCollection} from './TableCollection';\nimport {useCollection} from '@react-stately/collections';\n\nexport interface TableState<T> extends GridState<T, ITableCollection<T>> {\n  /** A collection of rows and columns in the table. */\n  collection: ITableCollection<T>,\n  /** Whether the row selection checkboxes should be displayed. */\n  showSelectionCheckboxes: boolean,\n  /** The current sorted column and direction. */\n  sortDescriptor: SortDescriptor,\n  /** Calls the provided onSortChange handler with the provided column key and sort direction. */\n  sort(columnKey: Key, direction?: 'ascending' | 'descending'): void,\n  /** Whether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell. */\n  isKeyboardNavigationDisabled: boolean,\n  /** Set whether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell. */\n  setKeyboardNavigationDisabled: (val: boolean) => void\n}\n\nexport interface CollectionBuilderContext<T> {\n  showSelectionCheckboxes: boolean,\n  selectionMode: SelectionMode,\n  columns: Node<T>[]\n}\n\nexport interface TableStateProps<T> extends CollectionBase<T>, MultipleSelectionStateProps, Sortable {\n  /** Whether the row selection checkboxes should be displayed. */\n  showSelectionCheckboxes?: boolean\n}\n\nconst OPPOSITE_SORT_DIRECTION = {\n  ascending: 'descending' as SortDirection,\n  descending: 'ascending' as SortDirection\n};\n\n/**\n * Provides state management for a table component. Handles building a collection\n * of columns and rows from props. In addition, it tracks row selection and manages sort order changes.\n */\nexport function useTableState<T extends object>(props: TableStateProps<T>): TableState<T> {\n  let [isKeyboardNavigationDisabled, setKeyboardNavigationDisabled] = useState(false);\n  let {selectionMode = 'none'} = props;\n\n  let context = useMemo(() => ({\n    showSelectionCheckboxes: props.showSelectionCheckboxes && selectionMode !== 'none',\n    selectionMode,\n    columns: []\n  }), [props.children, props.showSelectionCheckboxes, selectionMode]);\n\n  let collection = useCollection<T, TableCollection<T>>(\n    props,\n    (nodes, prev) => new TableCollection(nodes, prev, context),\n    context\n  );\n  let {disabledKeys, selectionManager} = useGridState({...props, collection});\n\n  return {\n    collection,\n    disabledKeys,\n    selectionManager,\n    showSelectionCheckboxes: props.showSelectionCheckboxes || false,\n    sortDescriptor: props.sortDescriptor,\n    isKeyboardNavigationDisabled: collection.size === 0 || isKeyboardNavigationDisabled,\n    setKeyboardNavigationDisabled,\n    sort(columnKey: Key, direction?: 'ascending' | 'descending') {\n      props.onSortChange({\n        column: columnKey,\n        direction: direction ?? (props.sortDescriptor?.column === columnKey\n          ? OPPOSITE_SORT_DIRECTION[props.sortDescriptor.direction]\n          : 'ascending')\n      });\n    }\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {GridCollection} from '@react-stately/grid';\nimport {GridNode} from '@react-types/grid';\nimport {Key} from 'react';\n\ninterface GridCollectionOptions {\n  showSelectionCheckboxes?: boolean\n}\n\nconst ROW_HEADER_COLUMN_KEY = 'row-header-column-' + Math.random().toString(36).slice(2);\n\nfunction buildHeaderRows<T>(keyMap: Map<Key, GridNode<T>>, columnNodes: GridNode<T>[]): GridNode<T>[] {\n  let columns: GridNode<T>[][] = [];\n  let seen = new Map();\n  for (let column of columnNodes) {\n    let parentKey = column.parentKey;\n    let col = [column];\n\n    while (parentKey) {\n      let parent: GridNode<T> = keyMap.get(parentKey);\n\n      // If we've already seen this parent, than it is shared\n      // with a previous column. If the current column is taller\n      // than the previous column, than we need to shift the parent\n      // in the previous column so it's level with the current column.\n      if (seen.has(parent)) {\n        parent.colspan++;\n\n        let {column, index} = seen.get(parent);\n        if (index > col.length) {\n          break;\n        }\n\n        for (let i = index; i < col.length; i++) {\n          column.splice(i, 0, null);\n        }\n\n        // Adjust shifted indices\n        for (let i = col.length; i < column.length; i++) {\n          if (column[i] && seen.has(column[i])) {\n            seen.get(column[i]).index = i;\n          }\n        }\n      } else {\n        parent.colspan = 1;\n        col.push(parent);\n        seen.set(parent, {column: col, index: col.length - 1});\n      }\n\n      parentKey = parent.parentKey;\n    }\n\n    columns.push(col);\n    column.index = columns.length - 1;\n  }\n\n  let maxLength = Math.max(...columns.map(c => c.length));\n  let headerRows = Array(maxLength).fill(0).map(() => []);\n\n  // Convert columns into rows.\n  let colIndex = 0;\n  for (let column of columns) {\n    let i = maxLength - 1;\n    for (let item of column) {\n      if (item) {\n        // Fill the space up until the current column with a placeholder\n        let row = headerRows[i];\n        let rowLength = row.reduce((p, c) => p + c.colspan, 0);\n        if (rowLength < colIndex) {\n          let placeholder: GridNode<T> = {\n            type: 'placeholder',\n            key: 'placeholder-' + item.key,\n            colspan: colIndex - rowLength,\n            index: rowLength,\n            value: null,\n            rendered: null,\n            level: i,\n            hasChildNodes: false,\n            childNodes: [],\n            textValue: null\n          };\n\n          if (row.length > 0) {\n            row[row.length - 1].nextKey = placeholder.key;\n            placeholder.prevKey = row[row.length - 1].key;\n          }\n\n          row.push(placeholder);\n        }\n\n        if (row.length > 0) {\n          row[row.length - 1].nextKey = item.key;\n          item.prevKey = row[row.length - 1].key;\n        }\n\n        item.level = i;\n        item.colIndex = colIndex;\n        row.push(item);\n      }\n\n      i--;\n    }\n\n    colIndex++;\n  }\n\n  // Add placeholders at the end of each row that is shorter than the maximum\n  let i = 0;\n  for (let row of headerRows) {\n    let rowLength = row.reduce((p, c) => p + c.colspan, 0);\n    if (rowLength < columnNodes.length) {\n      let placeholder: GridNode<T> = {\n        type: 'placeholder',\n        key: 'placeholder-' + row[row.length - 1].key,\n        colspan: columnNodes.length - rowLength,\n        index: rowLength,\n        value: null,\n        rendered: null,\n        level: i,\n        hasChildNodes: false,\n        childNodes: [],\n        textValue: null,\n        prevKey: row[row.length - 1].key\n      };\n\n      row.push(placeholder);\n    }\n\n    i++;\n  }\n\n  return headerRows.map((childNodes, index) => {\n    let row: GridNode<T> = {\n      type: 'headerrow',\n      key: 'headerrow-' + index,\n      index,\n      value: null,\n      rendered: null,\n      level: 0,\n      hasChildNodes: true,\n      childNodes,\n      textValue: null\n    };\n\n    return row;\n  });\n}\n\nexport class TableCollection<T> extends GridCollection<T> {\n  headerRows: GridNode<T>[];\n  columns: GridNode<T>[];\n  rowHeaderColumnKeys: Set<Key>;\n  body: GridNode<T>;\n\n  constructor(nodes: Iterable<GridNode<T>>, prev?: TableCollection<T>, opts?: GridCollectionOptions) {\n    let rowHeaderColumnKeys: Set<Key> = new Set();\n    let body: GridNode<T>;\n    let columns = [];\n\n    // Add cell for selection checkboxes if needed.\n    if (opts?.showSelectionCheckboxes) {\n      let rowHeaderColumn: GridNode<T> = {\n        type: 'column',\n        key: ROW_HEADER_COLUMN_KEY,\n        value: null,\n        textValue: '',\n        level: 0,\n        index: 0,\n        hasChildNodes: false,\n        rendered: null,\n        childNodes: [],\n        props: {\n          isSelectionCell: true\n        }\n      };\n\n      columns.unshift(rowHeaderColumn);\n    }\n\n    let rows = [];\n    let columnKeyMap = new Map();\n    let visit = (node: GridNode<T>) => {\n      switch (node.type) {\n        case 'body':\n          body = node;\n          break;\n        case 'column':\n          columnKeyMap.set(node.key, node);\n          if (!node.hasChildNodes) {\n            columns.push(node);\n\n            if (node.props.isRowHeader) {\n              rowHeaderColumnKeys.add(node.key);\n            }\n          }\n          break;\n        case 'item':\n          rows.push(node);\n          return; // do not go into childNodes\n      }\n      for (let child of node.childNodes) {\n        visit(child);\n      }\n    };\n\n    for (let node of nodes) {\n      visit(node);\n    }\n\n    let headerRows = buildHeaderRows(columnKeyMap, columns) as GridNode<T>[];\n    headerRows.forEach((row, i) => rows.splice(i, 0, row));\n\n    super({\n      columnCount: columns.length,\n      items: rows,\n      visitNode: node => {\n        node.column = columns[node.index];\n        return node;\n      }\n    });\n    this.columns = columns;\n    this.rowHeaderColumnKeys = rowHeaderColumnKeys;\n    this.body = body;\n    this.headerRows = headerRows;\n\n    // Default row header column to the first one.\n    if (this.rowHeaderColumnKeys.size === 0) {\n      this.rowHeaderColumnKeys.add(this.columns[opts?.showSelectionCheckboxes ? 1 : 0].key);\n    }\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.body.childNodes;\n  }\n\n  get size() {\n    return [...this.body.childNodes].length;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    return [...this.body.childNodes][0]?.key;\n  }\n\n  getLastKey() {\n    let rows = [...this.body.childNodes];\n    return rows[rows.length - 1]?.key;\n  }\n\n  getItem(key: Key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx: number) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {PartialNode} from '@react-stately/collections';\nimport React, {ReactElement} from 'react';\nimport {TableHeaderProps} from '@react-types/table';\n\nfunction TableHeader<T>(props: TableHeaderProps<T>): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nTableHeader.getCollectionNode = function* getCollectionNode<T>(props: TableHeaderProps<T>): Generator<PartialNode<T>, void, any> {\n  let {children, columns} = props;\n  if (typeof children === 'function') {\n    if (!columns) {\n      throw new Error('props.children was a function but props.columns is missing');\n    }\n\n    for (let column of columns) {\n      yield {\n        type: 'column',\n        value: column,\n        renderer: children\n      };\n    }\n  } else {\n    let columns: PartialNode<T>[] = [];\n    React.Children.forEach(children, column => {\n      columns.push({\n        type: 'column',\n        element: column\n      });\n    });\n\n    yield* columns;\n  }\n};\n\n/**\n * A TableHeader is a container for the Column elements in a Table. Columns can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `columns` prop.\n */\n// We don't want getCollectionNode to show up in the type definition\nlet _TableHeader = TableHeader as <T>(props: TableHeaderProps<T>) => JSX.Element;\nexport {_TableHeader as TableHeader};\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {PartialNode} from '@react-stately/collections';\nimport React, {ReactElement} from 'react';\nimport {TableBodyProps} from '@react-types/table';\n\nfunction TableBody<T>(props: TableBodyProps<T>): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nTableBody.getCollectionNode = function* getCollectionNode<T>(props: TableBodyProps<T>): Generator<PartialNode<T>> {\n  let {children, items} = props;\n  yield {\n    type: 'body',\n    hasChildNodes: true,\n    props,\n    *childNodes() {\n      if (typeof children === 'function') {\n        if (!items) {\n          throw new Error('props.children was a function but props.items is missing');\n        }\n\n        for (let item of items) {\n          yield {\n            type: 'item',\n            value: item,\n            renderer: children\n          };\n        }\n      } else {\n        let items: PartialNode<T>[] = [];\n        React.Children.forEach(children, item => {\n          items.push({\n            type: 'item',\n            element: item\n          });\n        });\n\n        yield* items;\n      }\n    }\n  };\n};\n\n/**\n * A TableBody is a container for the Row elements of a Table. Rows can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `items` prop.\n */\n// We don't want getCollectionNode to show up in the type definition\nlet _TableBody = TableBody as <T>(props: TableBodyProps<T>) => JSX.Element;\nexport {_TableBody as TableBody};\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CollectionBuilderContext} from './useTableState';\nimport {ColumnProps} from '@react-types/table';\nimport {GridNode} from '@react-types/grid';\nimport {PartialNode} from '@react-stately/collections';\nimport React, {ReactElement} from 'react';\n\nfunction Column<T>(props: ColumnProps<T>): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nColumn.getCollectionNode = function* getCollectionNode<T>(props: ColumnProps<T>, context: CollectionBuilderContext<T>): Generator<PartialNode<T>, void, GridNode<T>[]> {\n  let {title, children, childColumns} = props;\n\n  let rendered = title || children;\n  let textValue = props.textValue || (typeof rendered === 'string' ? rendered : '') || props['aria-label'];\n\n  let fullNodes = yield {\n    type: 'column',\n    hasChildNodes: !!childColumns || (title && React.Children.count(children) > 0),\n    rendered,\n    textValue,\n    props,\n    *childNodes() {\n      if (childColumns) {\n        for (let child of childColumns) {\n          yield {\n            type: 'column',\n            value: child\n          };\n        }\n      } else if (title) {\n        let childColumns: PartialNode<T>[] = [];\n        React.Children.forEach(children, child => {\n          childColumns.push({\n            type: 'column',\n            element: child as ReactElement<ColumnProps<T>>\n          });\n        });\n\n        yield* childColumns;\n      }\n    },\n    shouldInvalidate(newContext: CollectionBuilderContext<T>) {\n      // This is a bit of a hack, but it works.\n      // If this method is called, then there's a cached version of this node available.\n      // But, we need to keep the list of columns in the new context up to date.\n      updateContext(newContext);\n      return false;\n    }\n  };\n\n  let updateContext = (context: CollectionBuilderContext<T>) => {\n    // register leaf columns on the context so that <Row> can access them\n    for (let node of fullNodes) {\n      if (!node.hasChildNodes) {\n        context.columns.push(node);\n      }\n    }\n  };\n\n  updateContext(context);\n};\n\n/**\n * A Column represents a field of each item within a Table. Columns may also contain nested\n * Column elements to represent column groups. Nested columns can be statically defined as\n * children, or dynamically generated using a function based on the `childColumns` prop.\n */\n// We don't want getCollectionNode to show up in the type definition\nlet _Column = Column as <T>(props: ColumnProps<T>) => JSX.Element;\nexport {_Column as Column};\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CollectionBuilderContext} from './useTableState';\nimport {PartialNode} from '@react-stately/collections';\nimport React, {ReactElement} from 'react';\nimport {RowProps} from '@react-types/table';\n\nfunction Row(props: RowProps): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nRow.getCollectionNode = function* getCollectionNode<T>(props: RowProps, context: CollectionBuilderContext<T>): Generator<PartialNode<T>> {\n  let {children, textValue} = props;\n\n  yield {\n    type: 'item',\n    props: props,\n    textValue,\n    'aria-label': props['aria-label'],\n    hasChildNodes: true,\n    *childNodes() {\n      // Process cells first\n      if (context.showSelectionCheckboxes && context.selectionMode !== 'none') {\n        yield {\n          type: 'cell',\n          key: 'header', // this is combined with the row key by CollectionBuilder\n          props: {\n            isSelectionCell: true\n          }\n        };\n      }\n\n      if (typeof children === 'function') {\n        for (let column of context.columns) {\n          yield {\n            type: 'cell',\n            element: children(column.key),\n            key: column.key // this is combined with the row key by CollectionBuilder\n          };\n        }\n      } else {\n        let cells: PartialNode<T>[] = [];\n        React.Children.forEach(children, cell => {\n          cells.push({\n            type: 'cell',\n            element: cell\n          });\n        });\n\n        if (cells.length !== context.columns.length) {\n          throw new Error(`Cell count must match column count. Found ${cells.length} cells and ${context.columns.length} columns.`);\n        }\n\n        yield* cells;\n      }\n    },\n    shouldInvalidate(newContext: CollectionBuilderContext<T>) {\n      // Invalidate all rows if the columns changed.\n      return newContext.columns.length !== context.columns.length ||\n        newContext.columns.some((c, i) => c.key !== context.columns[i].key) ||\n        newContext.showSelectionCheckboxes !== context.showSelectionCheckboxes ||\n        newContext.selectionMode !== context.selectionMode;\n    }\n  };\n};\n\n/**\n * A Row represents a single item in a Table and contains Cell elements for each column.\n * Cells can be statically defined as children, or generated dynamically using a function\n * based on the columns defined in the TableHeader.\n */\n// We don't want getCollectionNode to show up in the type definition\nlet _Row = Row as (props: RowProps) => JSX.Element;\nexport {_Row as Row};\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CellProps} from '@react-types/table';\nimport {PartialNode} from '@react-stately/collections';\nimport {ReactElement} from 'react';\n\nfunction Cell(props: CellProps): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nCell.getCollectionNode = function* getCollectionNode<T>(props: CellProps): Generator<PartialNode<T>> {\n  let {children} = props;\n\n  let textValue = props.textValue || (typeof children === 'string' ? children : '') || props['aria-label'] || '';\n  yield {\n    type: 'cell',\n    props: props,\n    rendered: children,\n    textValue,\n    'aria-label': props['aria-label'],\n    hasChildNodes: false\n  };\n};\n\n/**\n * A Cell represents the value of a single Column within a Table Row.\n */\n// We don't want getCollectionNode to show up in the type definition\nlet _Cell = Cell as (props: CellProps) => JSX.Element;\nexport {_Cell as Cell};\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useTabListState} from './useTabListState';\n\nexport type {TabListProps} from '@react-types/tabs';\nexport type {TabListState} from './useTabListState';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {SingleSelectListState, useSingleSelectListState} from '@react-stately/list';\nimport {TabListProps} from '@react-types/tabs';\nimport {useRef} from 'react';\n\n\nexport interface TabListState<T> extends SingleSelectListState<T> {\n  /** Whether the tab list is disabled. */\n  isDisabled: boolean\n}\n\n/**\n * Provides state management for a Tabs component. Tabs include a TabList which tracks\n * which tab is currently selected and displays the content associated with that Tab in a TabPanel.\n */\nexport function useTabListState<T extends object>(props: TabListProps<T>): TabListState<T> {\n  let state = useSingleSelectListState<T>({\n    ...props,\n    suppressTextValueWarning: true\n  });\n\n  let {\n    selectionManager,\n    collection,\n    selectedKey: currentSelectedKey\n  } = state;\n\n  let lastSelectedKey = useRef(currentSelectedKey);\n  // Ensure a tab is always selected (in case no selected key was specified or if selected item was deleted from collection)\n  let selectedKey = currentSelectedKey;\n  if (selectionManager.isEmpty || !collection.getItem(selectedKey)) {\n    selectedKey = collection.getFirstKey();\n    // loop over tabs until we find one that isn't disabled and select that\n    while (state.disabledKeys.has(selectedKey) && selectedKey !== collection.getLastKey()) {\n      selectedKey = collection.getKeyAfter(selectedKey);\n    }\n    // if this check is true, then every item is disabled, it makes more sense to default to the first key than the last\n    if (state.disabledKeys.has(selectedKey) && selectedKey === collection.getLastKey()) {\n      selectedKey = collection.getFirstKey();\n    }\n    // directly set selection because replace/toggle selection won't consider disabled keys\n    selectionManager.setSelectedKeys([selectedKey]);\n  }\n\n  // If the tablist doesn't have focus and the selected key changes or if there isn't a focused key yet, change focused key to the selected key if it exists.\n  if (selectionManager.focusedKey == null || (!selectionManager.isFocused && selectedKey !== lastSelectedKey.current)) {\n    selectionManager.setFocusedKey(selectedKey);\n  }\n  lastSelectedKey.current = selectedKey;\n\n  return {\n    ...state,\n    isDisabled: props.isDisabled || false\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useTooltipTriggerState} from './useTooltipTriggerState';\n\nexport type {TooltipTriggerProps} from '@react-types/tooltip';\nexport type {TooltipTriggerState} from './useTooltipTriggerState';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {TooltipTriggerProps} from '@react-types/tooltip';\nimport {useEffect, useMemo, useRef} from 'react';\nimport {useOverlayTriggerState} from '@react-stately/overlays';\n\nconst TOOLTIP_DELAY = 1500; // this seems to be a 1.5 second delay, check with design\nconst TOOLTIP_COOLDOWN = 500;\n\nexport interface TooltipTriggerState {\n  /** Whether the tooltip is currently showing. */\n  isOpen: boolean,\n  /**\n   * Shows the tooltip. By default, the tooltip becomes visible after a delay\n   * depending on a global warmup timer. The `immediate` option shows the\n   * tooltip immediately instead.\n   */\n  open(immediate?: boolean): void,\n  /** Hides the tooltip. */\n  close(immediate?: boolean): void\n}\n\nlet tooltips = {};\nlet tooltipId = 0;\nlet globalWarmedUp = false;\nlet globalWarmUpTimeout = null;\nlet globalCooldownTimeout = null;\n\n/**\n * Manages state for a tooltip trigger. Tracks whether the tooltip is open, and provides\n * methods to toggle this state. Ensures only one tooltip is open at a time and controls\n * the delay for showing a tooltip.\n */\nexport function useTooltipTriggerState(props: TooltipTriggerProps = {}): TooltipTriggerState {\n  let {delay = TOOLTIP_DELAY} = props;\n  let {isOpen, open, close} = useOverlayTriggerState(props);\n  let id = useMemo(() => `${++tooltipId}`, []);\n  let closeTimeout = useRef<ReturnType<typeof setTimeout>>();\n\n  let ensureTooltipEntry = () => {\n    tooltips[id] = hideTooltip;\n  };\n\n  let closeOpenTooltips = () => {\n    for (let hideTooltipId in tooltips) {\n      if (hideTooltipId !== id) {\n        tooltips[hideTooltipId](true);\n        delete tooltips[hideTooltipId];\n      }\n    }\n  };\n\n  let showTooltip = () => {\n    clearTimeout(closeTimeout.current);\n    closeTimeout.current = null;\n    closeOpenTooltips();\n    ensureTooltipEntry();\n    globalWarmedUp = true;\n    open();\n    if (globalWarmUpTimeout) {\n      clearTimeout(globalWarmUpTimeout);\n      globalWarmUpTimeout = null;\n    }\n    if (globalCooldownTimeout) {\n      clearTimeout(globalCooldownTimeout);\n      globalCooldownTimeout = null;\n    }\n  };\n\n  let hideTooltip = (immediate?: boolean) => {\n    if (immediate) {\n      clearTimeout(closeTimeout.current);\n      closeTimeout.current = null;\n      close();\n    } else if (!closeTimeout.current) {\n      closeTimeout.current = setTimeout(() => {\n        closeTimeout.current = null;\n        close();\n      }, TOOLTIP_COOLDOWN);\n    }\n\n    if (globalWarmUpTimeout) {\n      clearTimeout(globalWarmUpTimeout);\n      globalWarmUpTimeout = null;\n    }\n    if (globalWarmedUp) {\n      if (globalCooldownTimeout) {\n        clearTimeout(globalCooldownTimeout);\n      }\n      globalCooldownTimeout = setTimeout(() => {\n        delete tooltips[id];\n        globalCooldownTimeout = null;\n        globalWarmedUp = false;\n      }, TOOLTIP_COOLDOWN);\n    }\n  };\n\n  let warmupTooltip = () => {\n    closeOpenTooltips();\n    ensureTooltipEntry();\n    if (!isOpen && !globalWarmUpTimeout && !globalWarmedUp) {\n      globalWarmUpTimeout = setTimeout(() => {\n        globalWarmUpTimeout = null;\n        globalWarmedUp = true;\n        showTooltip();\n      }, delay);\n    } else if (!isOpen) {\n      showTooltip();\n    }\n  };\n\n  // eslint-disable-next-line arrow-body-style\n  useEffect(() => {\n    return () => {\n      clearTimeout(closeTimeout.current);\n      let tooltip = tooltips[id];\n      if (tooltip) {\n        delete tooltips[id];\n      }\n    };\n  }, [id]);\n\n  return {\n    isOpen,\n    open: (immediate) => {\n      if (!immediate && delay > 0 && !closeTimeout.current) {\n        warmupTooltip();\n      } else {\n        showTooltip();\n      }\n    },\n    close: hideTooltip\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nexport type {TreeProps, TreeState} from './useTreeState';\nexport {useTreeState} from './useTreeState';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, CollectionBase, Expandable, MultipleSelection, Node} from '@react-types/shared';\nimport {Key, useEffect, useMemo} from 'react';\nimport {SelectionManager, useMultipleSelectionState} from '@react-stately/selection';\nimport {TreeCollection} from './TreeCollection';\nimport {useCollection} from '@react-stately/collections';\nimport {useControlledState} from '@react-stately/utils';\n\nexport interface TreeProps<T> extends CollectionBase<T>, Expandable, MultipleSelection {}\nexport interface TreeState<T> {\n  /** A collection of items in the tree. */\n  readonly collection: Collection<Node<T>>,\n\n  /** A set of keys for items that are disabled. */\n  readonly disabledKeys: Set<Key>,\n\n  /** A set of keys for items that are expanded. */\n  readonly expandedKeys: Set<Key>,\n\n  /** Toggles the expanded state for an item by its key. */\n  toggleKey(key: Key): void,\n\n  /** A selection manager to read and update multiple selection state. */\n  readonly selectionManager: SelectionManager\n}\n\n/**\n * Provides state management for tree-like components. Handles building a collection\n * of items from props, item expanded state, and manages multiple selection state.\n */\nexport function useTreeState<T extends object>(props: TreeProps<T>): TreeState<T> {\n  let [expandedKeys, setExpandedKeys] = useControlledState(\n    props.expandedKeys ? new Set(props.expandedKeys) : undefined,\n    props.defaultExpandedKeys ? new Set(props.defaultExpandedKeys) : new Set(),\n    props.onExpandedChange\n  );\n\n  let selectionState = useMultipleSelectionState(props);\n  let disabledKeys = useMemo(() =>\n    props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()\n  , [props.disabledKeys]);\n\n  let tree = useCollection(props, nodes => new TreeCollection(nodes, {expandedKeys}), null, [expandedKeys]);\n\n  // Reset focused key if that item is deleted from the collection.\n  useEffect(() => {\n    if (selectionState.focusedKey != null && !tree.getItem(selectionState.focusedKey)) {\n      selectionState.setFocusedKey(null);\n    }\n  }, [tree, selectionState.focusedKey]);\n\n  let onToggle = (key: Key) => {\n    setExpandedKeys(toggleKey(expandedKeys, key));\n  };\n\n  return {\n    collection: tree,\n    expandedKeys,\n    disabledKeys,\n    toggleKey: onToggle,\n    selectionManager: new SelectionManager(tree, selectionState)\n  };\n}\n\nfunction toggleKey(set: Set<Key>, key: Key): Set<Key> {\n  let res = new Set(set);\n  if (res.has(key)) {\n    res.delete(key);\n  } else {\n    res.add(key);\n  }\n\n  return res;\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, Node} from '@react-types/shared';\nimport {Key} from 'react';\n\nexport class TreeCollection<T> implements Collection<Node<T>> {\n  private keyMap: Map<Key, Node<T>> = new Map();\n  private iterable: Iterable<Node<T>>;\n  private firstKey: Key;\n  private lastKey: Key;\n\n  constructor(nodes: Iterable<Node<T>>, {expandedKeys}: {expandedKeys?: Set<Key>} = {}) {\n    this.iterable = nodes;\n    expandedKeys = expandedKeys || new Set();\n\n    let visit = (node: Node<T>) => {\n      this.keyMap.set(node.key, node);\n\n      if (node.childNodes && (node.type === 'section' || expandedKeys.has(node.key))) {\n        for (let child of node.childNodes) {\n          visit(child);\n        }\n      }\n    };\n\n    for (let node of nodes) {\n      visit(node);\n    }\n\n    let last: Node<T>;\n    let index = 0;\n    for (let [key, node] of this.keyMap) {\n      if (last) {\n        last.nextKey = key;\n        node.prevKey = last.key;\n      } else {\n        this.firstKey = key;\n        node.prevKey = undefined;\n      }\n\n      if (node.type === 'item') {\n        node.index = index++;\n      }\n\n      last = node;\n\n      // Set nextKey as undefined since this might be the last node\n      // If it isn't the last node, last.nextKey will properly set at start of new loop\n      last.nextKey = undefined;\n    }\n\n    this.lastKey = last?.key;\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.iterable;\n  }\n\n  get size() {\n    return this.keyMap.size;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    return this.firstKey;\n  }\n\n  getLastKey() {\n    return this.lastKey;\n  }\n\n  getItem(key: Key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx: number) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n}\n"],
  "mappings": "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",
  "names": ["$keQhS$useMemo", "$keQhS$useState", "$keQhS$useRef", "$Qsto2$useRef", "$Qsto2$useState", "$Qsto2$useMemo", "$Qsto2$useEffect", "$58Phs$useMemo", "$58Phs$useEffect", "$9Xvoh$useState", "$k6Ppu$useState", "$k6Ppu$useMemo", "$k6Ppu$useRef", "$k6Ppu$useEffect", "$7UzoM$useRef", "$7UzoM$useState", "$7UzoM$useMemo", "$7UzoM$useEffect", "$d70Aq$useState", "$d70Aq$useMemo", "$d70Aq$useReducer", "$d70Aq$useEffect", "$vhjCi$useState", "$vhjCi$useMemo", "$vhjCi$useCallback", "$vhjCi$useRef", "$fQ2SF$useMemo", "$fQ2SF$useState", "$e17gp$useState", "$aTwux$useMemo", "$aTwux$useState", "$aTwux$useRef", "$cAn5f$useMemo", "$cAn5f$useEffect", "column", "i", "$1BfjW$useState", "$1BfjW$useMemo", "columns", "$1BfjW$react", "getCollectionNode", "$ijHKZ$useRef", "$1OhDq$useMemo", "$1OhDq$useRef", "$1OhDq$useEffect", "$1OoTj$useMemo", "$1OoTj$useEffect"]
}
